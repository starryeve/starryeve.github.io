{"title":"js异步语法","uid":"5fa09e61f4099275ac11d38388630b65","slug":"js异步语法","date":"2021-01-09T12:54:26.000Z","updated":"2022-01-12T10:47:04.244Z","comments":true,"path":"api/articles/js异步语法.json","keywords":null,"cover":[],"content":"<p>无论是新人还是老人，无论是学习源码，还是自己开发，我们经常会遇到这样的情况：书写好的几行代码，想要需要知道其输出内容和顺序。而 JavaScrip 作为单线程语言，就有一个很自然而然的结论啦：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JavaScript是按照语句出现的顺序执行的<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>说是这么说，当有那么一天，你的经理丢给你一个老项目，让你好好接手，说完就提桶跑路了，你很开心，回到 C503，想着自己终于可以做项目了，开开心心用 VsCode 打开那个项目：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let key &#x3D; &#39;&#39; &#x2F;&#x2F; 密钥\nlet token &#x3D; &#39;&#39; &#x2F;&#x2F; 用户token\nlet userID &#x3D; &#39;&#39; &#x2F;&#x2F; 用户id\n\n$.ajax(&#123;\n    type: &#39;get&#39;,\n    url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getKey&#39;, &#x2F;&#x2F; 获取接口密钥，作为之后调用获取用户信息接口的参数\n    success: data &#x3D;&gt; &#123;\n        key &#x3D; data;\n        $.ajax(&#123;\n            type: &#39;get&#39;,\n            url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getUserInfo&#39;, &#x2F;&#x2F; 获取用户登录信息\n            data: &#123;\n                key: key\n            &#125;,\n            success: data &#x3D;&gt; &#123;\n                token &#x3D; data.token\n                userId &#x3D; data.userID\n                $.ajax(&#123;\n                    type: &#39;get&#39;,\n                    url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getPrivacy&#39;, &#x2F;&#x2F; 获取用户的个人隐私数据\n                    data: &#123;\n                        token: token,\n                        userId: userID\n                    &#125;,\n                    success: data &#x3D;&gt; &#123;\n                      const data &#x3D; data\n                      &#96;&#96;&#96;&#96;\n                      dom操作渲染到页面上\n                      &#96;&#96;&#96;&#96;\n                    &#125;,\n                    error: err &#x3D;&gt; &#123;\n                        console.log(err);\n                    &#125;\n                &#125;);\n            &#125;,\n            error: err &#x3D;&gt; &#123;\n                console.log(err);\n            &#125;\n        &#125;);\n    &#125;,\n    error: err &#x3D;&gt; &#123;\n        console.log(err);\n    &#125;\n&#125;);\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码的执行确实是从上往下的，只不过随着请求的次数变多，横向的代码也在不断扩张，这就给调试带来了不少困难了。更让人揪心的是，ajax 请求的结果并不总是成功的，我们不得不从一个函数跳到下一个，再跳到下一个，对每次请求可能出现的错误都要做处理。<br><img src=\"./img/emmm.jpg\" alt=\"avatar\"></p>\n<h2 id=\"CallBack\"><a href=\"#CallBack\" class=\"headerlink\" title=\"CallBack\"></a>CallBack</h2><p>上面的代码就是早期常用的异步解决方案————CallBack，即回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。即异步操作执行完成后触发执行的函数，这就很适合诸如网络请求、文件读取等等需要耗费大量时间的操作。但事实上，它也有不少缺点：</p>\n<ul>\n<li>缺乏顺序性：连续回调导致的调试困难，和大脑的思维方式不符</li>\n<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，</li>\n<li>嵌套函数过多的话，很难处理错误<br><img src=\"./img/%E5%9C%B0%E7%8B%B1%E5%9B%9E%E8%B0%83.jpg\" alt=\"avatar\"></li>\n</ul>\n<p>这些缺点可以总结为我们常说的地狱回调（Callback Hell），是显式的，在书写的过程中很容易就能感知到。除了这些，Callback 实现的异步操作还有没有其他问题呢？请看思考以下下面的代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; A\n$.ajax(&#123;\n    ...\n    success: (...) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; C\n    &#125;\n&#125;);\n&#x2F;&#x2F; B<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>A 和 B 发生于现在，在 JavaScript 主程序的直接控制之下，而 C 会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。这种由第三方执行回调的情况就叫做控制反转，可以想象，既然不是自己的代码，回调处理时很有可能遇到以下信任内容：<br><img src=\"./img/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.png\" alt=\"avatar\"></p>\n<p>这种信任问题，怎么解决？</p>\n<p>以青春期的恋爱关系为例，一个成绩很不好的男孩子喜欢上了一个成绩很好的女孩子，他想追到她，女孩子呢，也有这个心思，可是两人都快高考了，女孩子不想因为谈恋爱而耽误了学业。这个时候，她给了男孩子一个承诺，如果男孩子能在剩下的几十天内努力学习，并和她考上相同的大学，她就跟他在一起。无论男孩子在接下来的时间里怎么做，这个许下的承诺，在高考结束后都是确定的，没有丝毫暧昧的。</p>\n<p>在 JavaScript 的异步世界里，女孩子的承诺就是一个 Promise</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"Promise-的状态\"><a href=\"#Promise-的状态\" class=\"headerlink\" title=\"Promise 的状态\"></a>Promise 的状态</h3><p>一个 Promise 必然有以下几个状态：</p>\n<ul>\n<li>待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</li>\n<li>已兑现（fulfilled）: 意味着操作成功完成。</li>\n<li>已拒绝（rejected）: 意味着操作失败。</li>\n</ul>\n<p><img src=\"./img/promise.png\" alt=\"avatar\"><br>待定状态的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个原因（错误）被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。也就是说女孩子的承诺不会产生信任问题，男孩子可以一心一意地努力考上大学。</p>\n<h3 id=\"Promise-情景实现\"><a href=\"#Promise-情景实现\" class=\"headerlink\" title=\"Promise 情景实现\"></a>Promise 情景实现</h3><p>下面是对上述情景的代码实现：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;         &#x2F;&#x2F; 经过了三个月(这里以3000ms模拟三个月)\n    const result &#x3D; Math.random() &gt;&#x3D; 0.1 ? &#39;考上了&#39; : &#39;没考上&#39; &#x2F;&#x2F; 模拟结果\n    if (result &#x3D;&#x3D;&#x3D; &#39;考上了&#39;) &#123;\n      resolve(&#39;我可以追她啦！&#39;)    &#x2F;&#x2F; 男孩子奋发图强，最终考上和女孩子一样的大学\n    &#125; else &#123;\n      reject(&#39;我没脸见她了。&#39;)     &#x2F;&#x2F;男孩子自甘堕落，最终落榜\n    &#125;\n  &#125;, 3000)\n&#125;)\n\n\nlove.then(result &#x3D;&gt; &#123;\n  console.log(result)\n&#125;).catch(error &#x3D;&gt; &#123;\n  console.log(error)\n&#125;)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"./img/success.png\" alt=\"avatar\"></p>\n<h3 id=\"Promise-的状态一经改变不可逆\"><a href=\"#Promise-的状态一经改变不可逆\" class=\"headerlink\" title=\"Promise 的状态一经改变不可逆\"></a>Promise 的状态一经改变不可逆</h3><p>需要特别注意的是，Promise 在经过 pending 状态达到成功或失败状态时就会凝固，即到达成功状态后再也不会转变为失败，失败以后也不会回到成功状态。即，状态的改变是不可逆的，你可以理解为女孩的这个承诺只会生效一次，哪怕男孩子考砸了去复读了一年后考上跟她一样的大学，他们也没可能了。</p>\n<p>这种只决议一次的特性，就解决了回调可能产生的多次调用问题。</p>\n<h3 id=\"使用-Promise-重构-Callback\"><a href=\"#使用-Promise-重构-Callback\" class=\"headerlink\" title=\"使用 Promise 重构 Callback\"></a>使用 Promise 重构 Callback</h3><p>回到开头经理丢给我们的代码，我们尝试着用 Promise 的方式去重构它：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const getKey &#x3D;  () &#x3D;&gt; &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        $.ajax(&#123;\n            url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getKey&#39;,\n            success: data &#x3D;&gt; &#123;\n               const key &#x3D; data;\n               resolve(key);\n            &#125;,\n            error: err &#x3D;&gt; &#123;\n                reject(err);\n            &#125;\n        &#125;);\n    &#125;);\n&#125;;\n\nconst getUserInfo &#x3D; key &#x3D;&gt; &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        $.ajax(&#123;\n            url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getUserInfo&#39;,\n            data: &#123;\n                key: key\n            &#125;,\n            success: data &#x3D;&gt; &#123;\n                const userInfo &#x3D; data\n                resolve(userInfo);\n            &#125;,\n            error: err &#x3D;&gt; &#123;\n                reject(err);\n            &#125;\n        &#125;);\n    &#125;);\n&#125;;\n\nconst getPrivacy &#x3D; userInfo &#x3D;&gt; &#123;\n    let token &#x3D; userInfo.token;\n    let userID &#x3D; userInfo.userID;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        $.ajax(&#123;\n            url: &#39;https:&#x2F;&#x2F;www.xxx.com&#x2F;getPrivacy&#39;,\n            data: &#123;\n                token: token,\n                userId: userID\n            &#125;,\n            success: data &#x3D;&gt; &#123;\n                resolve(data);\n            &#125;,\n            error: err &#x3D;&gt; &#123;\n                reject(err);\n            &#125;\n        &#125;);\n    &#125;);\n&#125;;\n\ngetKey()\n    .then(key &#x3D;&gt; &#123;\n        return getUserInfo(key);\n    &#125;)\n    .then(userInfo &#x3D;&gt; &#123;\n        return getPrivacy(userInfo);\n    &#125;)\n    .then(data &#x3D;&gt; &#123;\n        ....\n    &#125;)\n    .catch(err &#x3D;&gt; &#123;\n        console.log(err);\n    &#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，使用 Promise，代码结构能明显改善，将多个异步逻辑拆分成函数之后，再链式调用的方式，也比回调更加有逻辑性，我们能直观地定位我们最终需要的数据。</p>\n<p>但事实上，Promise 并没有摆脱回调函数，它只是改变了传递回调的位置。我们并不是把回调传递给某个第三方函数去执行，而是从该函数得到某个东西（Promise 对象），然后把回调传递给这个东西（Promise.resolve(…))再通过 then(…)进行接收处理，即将控制反转再反转，一定程度上避免了信任问题。</p>\n<h2 id=\"Async-Await-初识\"><a href=\"#Async-Await-初识\" class=\"headerlink\" title=\"Async/Await 初识\"></a>Async/Await 初识</h2><p>Callback 的出现实现了异步，但也仅仅是满足了基本需求，Promise 的诞生解决了地狱回调和信任缺失，但这两者在编写代码时候的书写流程，似乎都不太符合我们大脑的直觉。有没有一种解决方案，能让异步的代码写起来像同步一样舒服呢？<br>套用阮一峰大神的一句话————“异步编程的最高境界，就是根本不用关心它是不是异步。”</p>\n<p>ES7 提出的 async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。<br>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span>Generator是ES6的一个重要概念，是JavaScript摆脱回调实现异步的基础，感兴趣的同学可以先参考下面这篇文章，篇幅有限，就不多介绍了。\nGenerator 函数的含义与用法：\nhttp://www.ruanyifeng.com/blog/2015/04/generator.html</blockquote>\n\n<h3 id=\"Async-Await-重构-开头的例子\"><a href=\"#Async-Await-重构-开头的例子\" class=\"headerlink\" title=\"Async/Await 重构 开头的例子\"></a>Async/Await 重构 开头的例子</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 上面的三个异步函数跟前文Promise的是一样的，这也可以看出async&#x2F;await 语法的内部实现还是使用到了 promise\n\nasync function getData () &#123;\n  try &#123;\n    const key &#x3D; await getKey();\n    const userInfo &#x3D; await getUserInfo(key);\n    const privacy &#x3D; await getPrivacy(userInfo);\n\n    return privacy\n  &#125; catch(err) &#x3D;&gt; &#123;\n    return err\n  &#125;\n\n&#125;\n\nconst privacy &#x3D;  getData()\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面就是使用 async/await 的简单使用，但也能看得出，整个书写的过程明显节约了不少代码。我们不需要写.then()，不需要写匿名函数处理 Promise 的 resolve 值，也不需要定义多余的 data 变量….更让人高兴的是，它是一种看似同步的异步流程控制表达风格，应对复杂的业务时，能使得整个逻辑表现得更加清晰，可能说目前最为优雅的 JavaScript 处理异步的方式了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>Callback：异步方案的最初实践，容易引起回调地狱和控制反转</li>\n<li>Promise：解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来，将回调成功返回的数据送回 JavaScript 主流程中。</li>\n<li>Async/Await：结合了 Promise 和 Generator 的语法糖，真正实现了用同步的方式书写异步代码。</li>\n</ul>\n<p>以上就是对 JavaScript 异步编程发展历程的介绍了，但也仅仅是简单介绍而已，许多知识还要在实际学习和开发中才能慢慢体会，加油！</p>\n<p><img src=\"./img/%E5%93%86%E5%95%A6a.jpg\" alt=\"avatar\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous\">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/promise\">https://es6.ruanyifeng.com/#docs/promise</a></li>\n<li><a href=\"https://juejin.cn/post/6844903641455788045#heading-15\">https://juejin.cn/post/6844903641455788045#heading-15</a></li>\n</ul>\n<p><img src=\"./img/avatar.png\" alt=\"avatar\"></p>\n","text":"无论是新人还是老人，无论是学习源码，还是自己开发，我们经常会遇到这样的情况：书写好的几行代码，想要需要知道其输出内容和顺序。而 JavaScrip 作为单线程语言，就有一个很自然而然的结论啦： JavaScript是按照语句出现的顺序执行的 说是这么说，当有那么一天，你的经理丢给...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"javascript","slug":"javascript","count":1,"path":"api/categories/javascript.json"}],"tags":[{"name":"javascript","slug":"javascript","count":1,"path":"api/tags/javascript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CallBack\"><span class=\"toc-text\">CallBack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">Promise 的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-%E6%83%85%E6%99%AF%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Promise 情景实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%80%E7%BB%8F%E6%94%B9%E5%8F%98%E4%B8%8D%E5%8F%AF%E9%80%86\"><span class=\"toc-text\">Promise 的状态一经改变不可逆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Promise-%E9%87%8D%E6%9E%84-Callback\"><span class=\"toc-text\">使用 Promise 重构 Callback</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Async-Await-%E5%88%9D%E8%AF%86\"><span class=\"toc-text\">Async&#x2F;Await 初识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Async-Await-%E9%87%8D%E6%9E%84-%E5%BC%80%E5%A4%B4%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">Async&#x2F;Await 重构 开头的例子</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol>","author":{"name":"eve","slug":"blog-author","avatar":"https://gitee.com/zeng-fanhao/figure-bed/raw/master/images/202201171207395.png","link":"/","description":"","socials":{"github":"https://github.com/starryeve","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/562570281888488","customs":{}}},"mapped":true,"prev_post":{"title":"git commit 规范","uid":"15641e944ff08245a19bc3e150705e0f","slug":"git commit 规范","date":"2021-01-09T12:54:26.000Z","updated":"2022-01-18T06:43:35.659Z","comments":true,"path":"api/articles/git commit 规范.json","keywords":null,"cover":[],"text":"git commit 规范 Commit Message 格式目前使用最广泛的是Conventional Commits Specification（约定式提交规范），它是基于Angular团队的代码提交规范而产生的。message如下： &lt;类型&gt;[可选的作用域]：&...","link":"","photos":[],"count_time":{"symbolsCount":936,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":2,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"eve","slug":"blog-author","avatar":"https://gitee.com/zeng-fanhao/figure-bed/raw/master/images/202201171207395.png","link":"/","description":"","socials":{"github":"https://github.com/starryeve","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/562570281888488","customs":{}}}},"next_post":{"title":"node应用运行在服务器上","uid":"10c2a3aed0f7bff1bb8a5969f29219a5","slug":"node应用运行在服务器上","date":"2020-12-20T09:23:17.000Z","updated":"2022-01-12T10:47:04.247Z","comments":true,"path":"api/articles/node应用运行在服务器上.json","keywords":null,"cover":[],"text":"node 持续运行想要 node 应用持续运行在 Linux 服务器上，不被杀掉进程，要使用 nohub node app.js 命令 每次修改代码，重新打包部署之后，要先 cd 到当前 node 应用目录，使用 lsof -i:3000（3000 是应用运行的端口）找到 PID...","link":"","photos":[],"count_time":{"symbolsCount":371,"symbolsTime":"1 mins."},"categories":[{"name":"node","slug":"node","count":2,"path":"api/categories/node.json"}],"tags":[{"name":"node","slug":"node","count":3,"path":"api/tags/node.json"}],"author":{"name":"eve","slug":"blog-author","avatar":"https://gitee.com/zeng-fanhao/figure-bed/raw/master/images/202201171207395.png","link":"/","description":"","socials":{"github":"https://github.com/starryeve","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/562570281888488","customs":{}}}}}