[{"id":"1ed68a3a19e8d33a6986f3ce51f04bc8","title":"前端CI/CD实践","content":"前言前置知识\nlinux\ndocker\nnginx\n\n可以干嘛可以解放双手\nCI/CD是什么CI/CD（Continuous Intergration/Continuous Delpoy），持续集成/持续部署，或者持续集成/持续交付（Continuous Delivery），是一种在开发阶段引入自动化来频繁交付应用的方法。从前端的角度看，CICD的流程中涉及：\n\nCI：代码push到托管平台之后的lint测试、单元测试\nCD：将build后的项目丢到远端 Nginx 的静态资源目录下\n\n\n\n构建/部署前后端分离的开发模式中，前端项目经常会使用框架进行开发，经由 Webpack（或者其他构建工具） 打包后的SPA应用（代码），本质上都是静态资源，只需要把它们都放到 Nginx的静态资源目录下，配好相关的路径，即可完成部署。\n前端项目的构建、部署、上线流程，从 简陋疏散 到 完善严谨 ，大致经历了以下几个阶段：\n手动挡\n\n本地执行 yarn build构建项目\n使用 transmit或其他支持 sftp的软件上传打包后的项目\n修改 Nginx 的 nginx.conf 文件，配置项目的访问路径\n\n手动部署操作起来很简单，但缺点也很明显，每次构建完都要人为地进行部署的动作，一方面减少了实际敲代码的时间，另一方面，人工操作免不了会有疏忽出错的时候。\n自动挡随着工程化的发展和工具链的成熟，项目部署不再像以前简单粗暴。前端代码的健壮性、可靠性越来越被重视，项目发布前往往需要 代码约束 和 代码测试 ，校验通过后服务器拉取最新的代码，进行 build 和 nginx 配置后才算完成整个部署的过程。\n\n\n代码扫描 yarn lint检查代码是否规范\nyarn unit进行单元测试\ngit push提交更改到远端仓库\n登录服务器，git pull拉取最新代码\nyarn build构建项目\n配置 nginx 访问路径\n\n这个阶段，我们借助一些工具，能够减少代码不规范或隐藏bug的问题。但所有的操作还是得一行一行命令去敲，项目真正的部署也还是需要手动去操作服务器。 \n\n\n\n\n\n\n\n\n\n其实完全可以将上面的操作细节都集成到一个 shell 脚本里，通知执行 shell 也能减少很多重复的工作。\nCI/CD上面提到，借助shell也能使得一部分操作自动化，但无论是代码扫描、单元测试还是项目的构建，都还是在本地的开发机上进行（或者说跟开发强耦合），有没有办法将这些附属的操作抽离出来，放到另外的专有环境下进行呢？\n现在很流行的 DevOps 理念中，CI/CD的那一环就能很好地实现。\n\n\n\n\n\n\n\n\n\n\nDevOps是一种思想理念，强调软件开发测试运维的一体化，目标是减少各个部门之间的沟通成本，从而实现软件的快速高质量的发布。CI/CD是一套实践方案，实现软件的构建测试部署的自动化。\nCI/CD实践 —— 前端项目自动化部署流程架构想要达到的效果远程当主分支代码发生改变，拉取主分支代码进行构建，完成后通过 ssh 上传到测试/开发服务器。\n实现的技术链路\n搭建过程docker环境的搭建\n安装 docker \n# 安装 docker 的依赖库，-y 选项表示所有的 Is this OK[y/d/N]，都会自动选择y\nyum install -y yum-utils device-mapper-persistent-data lvm2 \n\n# 添加 docker cd 软件源信息\nsudo yum-config-manager --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo\n\n# 安装 docker ce \nsudo yum install docker-ce\n启动 docker \nsudo systemctl enable docker # 设置开机自启\nsudo systemctl start docker /#  启动docker\n\n\n\n\n\n\n\n\n\n\ndocker contos 安装指南\n安装docker-composedocker-compose 用于定义和运行多容器 docker 应用程序，使用 yml 文件配置应用所需的所有服务。\n\n安装 docker-compose\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n提升权限\nsudo chmod +x /usr/local/bin/docker-compos\n\n\n\n\n\n\n\n\n\n\ndocker-compose 安装指南\n创建 docker-compose 应用这里为了方便， nginx 通过容器的方式去启动（不会影响到我目前的 nginx ），jenkins 就还是放在跟项目部署的服务器上（方便后续直接通过 shell 复制构建好的项目）\n（拉取nginx镜像，编写目录数据卷映射）\n\n拉取 nginx 镜像\ndocker pull nginx\n\ndocker images # 查看安装的镜像\n创建数据卷目录，以便挂载到容器里\n+ compose # docker-compose 配置目录\n\t- docker-compose.yml \n+ nginx  \t\t\n \t+ conf\t# nginx 配置\n \t\t- nginx.conf\n \t+ html\t# nginx 静态资源\n  \t- index.html\n编写 docker-compose.yml\nversion: '3'\nservices:                                            \n  cicd_nginx:\n    restart: always\n    image: nginx\n    container_name: nginx\n    ports:\n      - 3300:80\n      - 3301:433\n    volumes:\n      - ../nginx/html:/usr/share/nginx/html\n      - ../nginx/conf/nginx.conf:/etc/nginx/nginx.conf\n      - ../nginx/log:/var/log/nginx\n      - ../nginx/localtime:/etc/localtime:ro\n启动\ndocker-compose up -d\ndocker-compose stop //停止nginx和jenkins\n公网查看 nginx\n\n\n\n\nJenkins基本配置\n 前往 jenkins 容器挂载的数据卷中获得初始密码\n\n   cat /home/cicd_demo/jenkins/jenkins_home/secrets/initialAdminPassword \n\n\n\n\n\n\n\n\n\n\n这个密码只会显示一次，之后如果忘记密码需要重置\n\n输入密码进入页面之后，选择推荐安装\n\n可以看到，jenkins 会自动帮我们安装很多插件，比如最常用的 git\n\n\n新建账户\n\n\n进入到主页后，先前往 Manage Jenkins - Manage Plugins 安装需要用到的插件，目前就只需要安装 NodeJS\n![image-20220122172232223](/Users/starryeve/Library/Application Support/typora-user-images/image-20220122172232223.png)\n\n前往全局工具配置，安装需要的不同版本的 node 环境\n\n\n配置 github\n在配置之前，我们先要到 GitHub 生成 Personal access token。\n头像 - Settings - Developer settings - Personal access tokens - Generate new token，按下图勾选需要的权限\n\n还记得我吗要实现的效果吗？当主分支有新的代码提交，就要通知 jenkins 去拉取代码并进行构建。既然是通知，那么肯定就需要用到 Webhook。这里并不需要手动创建 Webhock，jenkins提供的插件会帮我们创建。\n\n\n\n\n\n\n\n\n\nWebhock\n接下来继续配置插件，**Manage Jenkisn - Config System - **，找到 Github 配置的部分\n\n点击添加凭证，选择 Jenkins，点击后会弹出一个添加凭据的窗口，Type 选择为 Secret text，将我们刚才生成的 Personal access token 复制到 Secret 一栏中，点击添加\n\n添加后在 Credentials 一栏选中 Secret text，勾选 Manage Hook，点击 Test connection，如果正确显示了GitHub 用户名，就说明配置成功了。\n\n\n经过上面几步后，就完成了两件事情，Node 环境的配置和 Github Webhock 的添加，下面就可以开始新建任务了。\n新建一个Item\n回到首页，新建一个自由风格的任务\n\n\n勾选 GitHub project，输入项目地址。将下面的 Source Code Management 选中为 Git，将你要构建部署的项目的 clone 地址填到 Repository URL 一栏中。\n\n\n如果是公开的仓库，Credentials可以选择无。这里我准备的是一个私有的仓库，还需要添加一个可以访问访问 Github账户 的凭证，添加方法类似上面配置 Github Webhock 。这里选择 ssh private key的方式\n\n\n设置构建触发器和构建环境\n\n\n编写构建shell\n\n\n\n经过上面的步骤，就算完成一个 Item了，当 Github主分支有新的代码提交，就会触发构建：\n\n总结还没有总结\n","slug":"前端CI-CD实践","date":"2022-01-20T17:11:50.000Z","categories_index":"","tags_index":"","author_index":"EVE"},{"id":"66d5432935a9e114e0c6473f5ec12a37","title":"如何写好JavaScript代码","content":"写好JS的三个原则各司其职Web天然具有分层的体系架构，HTML、CSS、JavaScript各自承担着结构、表现和行为的责任，这种鲜明的三层结构就能在一定程度上指导我们设计一个高可用、高可扩展的应用。\n网页换肤以一个具备 白天/夜间 模式切换的页面为例，我们先给出基本的HTML结构\n&lt;body>\n  &lt;input id=\"modeCheckbox\" type=\"checkbox\">\n  &lt;div class=\"content\">\n    &lt;header>\n      &lt;label id=\"modeBtn\" for=\"modeCheckbox\">☀️&lt;/label>\n      &lt;h1>header&lt;/h1>\n    &lt;/header>\n    &lt;main>\n      content\n    &lt;/main>\n  &lt;/div>\n&lt;/body>\n\n这里有几种实现方式：\n\n通过JavaScript动态修改CSS样式。\nconst btn = document.getElementById('modeBtn');\nbtn.addEventListener('click', (e) => &#123;\n  const body = document.body;\n  if(e.target.innerHTML === '☀️') &#123;\n    body.style.backgroundColor = 'black';\n    body.style.color = 'white';\n    e.target.innerHTML = '🌙';\n  &#125; else &#123;\n    body.style.backgroundColor = 'white';\n    body.style.color = 'black';\n    e.target.innerHTML = '☀️';\n  &#125;\n&#125;);\n通过JavaScript动态修改Class类名，间接修改CSS样式，🌙☀️的变化可以交由伪元素的content属性。\n&lt;style>\n  .night &#123;\n    background-color: black\n    colr: white\n  &#125;\n&lt;/style>\n\nconst btn = document.getElementById('modeBtn');\nbtn.addEventListener('click', (e) => &#123;\n  const body = document.body;\n  if(body.className !== 'night') &#123;\n    body.className = 'nignt';\n  &#125; else &#123;\n    body.className = '';\n  &#125;\n&#125;);\n纯展示性的需求，可以仅由HTML和CSS实现。\n#modeCheckbox:checked+.content &#123;\n   background-color: black;\n   color: white;\n   transition: all 1s;\n&#125;\n\n总结\nHTML/CSS/JS各司其职\n\n避免JS直接操作样式\n\nclass表示状态，JS控制状态\n\n纯展示类交互需求零JS方案\n\n\n组件封装电商轮播图原生JS写一个轮播图，具备组件的封装性、正确性、扩展性、复用性。\n方法：抽离组件，组件是指web页面上包含模板、样式和功能的单元，好的组件具备封装性、正确性、扩展性、复用性\n结构设计：HTML思考组件所需要的DOM结构，轮播图的主体是一个典型的列表结构，可以使用&lt;ul&gt;标签实现；控制轮播切换需要两个按钮，简单的&lt;div&gt;即可，轮播底部往往还会有轮播内容对应的控制点，同样使用&lt;ul&gt;。\n&lt;div class=\"slider\">\n  &lt;ul>\n    &lt;li class=\"slider__item--selected\">\n      &lt;img src=\"https://p5.ssl.qhimg.com/t0119c74624763dd070.png\"/>\n    &lt;/li>\n    &lt;li class=\"slider__item\">\n      &lt;img src=\"https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\"/>\n    &lt;/li>\n    &lt;li class=\"slider__item\">\n      &lt;img src=\"https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\"/>\n    &lt;/li>\n    &lt;li class=\"slider__item\">\n      &lt;img src=\"https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\"/>\n    &lt;/li>\n  &lt;/ul>\n  &lt;div class=\"slider__next\">&lt;/div>\n  &lt;div class=\"slider__previous\">&lt;/div>\n  &lt;ul class=\"slider__control\">\n    &lt;li class=\"slider__control-buttons--selected\">&lt;/li>\n    &lt;li class=\"slider__control-buttons\">&lt;/li>\n    &lt;li class=\"slider__control-buttons\">&lt;/li>\n    &lt;li class=\"slider__control-buttons\">&lt;/li>\n  &lt;/ul>\n&lt;/div>\n\n展示设计：CSS使用CSS position 绝对定义将列表项重叠在同一个位置，轮播图切换的状态使用修饰符（modifier），切换的动画使用CSS transition。\n.slider &#123;\n  position: relative;\n  width: 790px;\n  height: 340px;\n&#125;\n\n.slider ul &#123;\n  list-style-type:none;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n&#125;\n\n.slider__item,\n.slider__item--selected &#123;\n  position: absolute;\n  transition: opacity 1s;\n  opacity: 0;\n  text-align: center;\n&#125;\n\n.slider__item--selected &#123;\n  transition: opacity 1s;\n  opacity: 1;\n&#125;\n....\n\n行为设计：APIAPI设计应保证原子操作，职责单一，满足灵活性。 \n先回顾下轮播组件的需求：\n\n图片循环播放，每张图片停留若干时间\n图片能够切换到上一张/下一张\n小圆点能够跳转显示小圆点顺序对应的图片\n\n根据上述需求，设计出以下5个组件API（详细实现见文末引用）：\n\n然后，将这个组件封装为一个类——Slider。\n在写好结构和样式之后，通过new关键字调用，并使用setInterval实现循环播放：\nconst container = document.querySelector('.slider');\nconst slider = new Slider(&#123;container&#125;);\nsetInterval(() => &#123;\n  slider.slideNext();\n&#125;, 3000);\n\n行为设计：控制流实现了组件的API后，还需要实现用户的控制功能\n\n当用户点击左右两边的小箭头时，图片分别切换到上一张/下一张，并点亮与该图片相对应的小圆点\n当用户鼠标移进到底部小圆点时，则立即跳到小圆点顺序所对应的那张图片，停止轮播\n当用户鼠标移出底部小圆点后，图片再次恢复轮播\n\n所谓控制流就是给每个组件的部件添加上对应用户行为的事件监听器，并在合适的API方法体内移除这些事件监听器。\n在这个组件中，涉及到的有click、mouseover、mouseout事件，除此之外，还可以通过自定义事件，对控制流进行解耦\nslideTo() &#123;\n  ......\n  new CustomEvent('slide', &#123;bubbles: true, details &#125;); // slideNext()函数体中派发自定义事件，控制轮播图小点\n&#125;\n\n\n......\n\naddEventListener('slide', (evt) => &#123;&#125;)\n\n这个自定义事件（CustomEvent），作用是让底部小圆点控件监听slideTo方法。当slideTo方法执行后，这个方法就会分发一次slide事件，然后在这个事件中，更新底部小圆点的状态，让小圆点的状态和各自的图片状态对应起来。\n思考：改进空间回顾一下上面的几个步骤：\n\n设计HTML结构\n编写CSS样式\n设计组件API，对API进行修改，以添加控制流程\n\n到目前为止，这个组件已经已经满足了封装性、正确性，可以投入到生产环境中使用。但这个组件只能满足自身的使用，很难应对变化的需求，比如，如果我们不需要下方的控制圆点，还是要进入到slider类中，注释掉一些代码；如果我们仅需要一个一排控制点，控制一个列表的显示，我们还要另外编写其他组件。\n也就是说，还可以对原本的代码进行优化，满足一个好的组价需要的扩展性、复用性。\n重构：插件化\n将控制元素抽取成插件\n插件与组件之间通过依赖注入方式建立联系\n\n重构：模板化\n将html和css模板化，更易于扩展\n\n\n\n\n\n重构：组件框架\n将通用的组件模型抽象出来，自定义组件去实现Component的抽象方法\n\n\n\n\n总结\n组件设计的原则：\n封装性、正确性、扩展性、复用性\n\n实现组件的步骤：\n\n结构设计\n\n展示效果\n\n行为设计\n\nAPI（功能）\n\nEvent（控制流）\n\n\n\n\n\n三次重构\n\n插件化\n模板化\n抽象化（组件框架）\n\n\n\n过程抽象\n将过程和涉及到的状态封装到一个方法中国，让方法的调用者只关注输入和输出本身。\n高阶函数\n以函数作为参数\n以函数作为返回值\n经常用于函数装饰器\n\n常见的高阶函数有：\n\nonce\nfunction once(fn) &#123;\n\treturn function(..args) &#123;\n\t\tif(fn) &#123;\n      const result = fn.apply(this, args);\n      fn = null;\n      return result;\n    &#125;\n\t&#125;\n&#125;\ndebounce\nfunction debounce(fn, dur = 1000) &#123;\n\tlet timer;\n\treturn function() &#123;\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => &#123;\n      fn.apply(this, arguments);\n    &#125;, dur) \n\t&#125;\n&#125;\nthrottle\nfunction throttle(fn, time = 1000) &#123;\n  let timer;\n  return function(...args) &#123;\n    if(timer === null) &#123;\n      fn.apply(this, args);\n      timer = setTimeout(() => &#123;\n        timer = null;\n      &#125;, time)\n    &#125;\n  &#125;\n&#125;\nconsumer\n\niterative\n\n\n为什么要使用高阶函数？易于减少非纯函数，通过测试高阶函数，间接地测试被高阶函数包裹的非纯函数。比如，有一个操作dom的非纯函数，还有一个批量操作的interative高阶函数，就可以通过iterative批量操作dom\n编程范式纯函数 &amp; 非纯函数命令式 &amp; 声明式总结：\n过程抽象/HOF/装饰器\n命令式/声明式（toggle函数）\n\n如何写好JavaScript代码写代码应该关注\n效率\n风格\n使用场景\n约定\n设计\n\n具体的代码实现要因场景而定，不同的场景注重点不一样，例如在某些比较底层的场景，可能更注重效率，而在多人协作的时候可能更关注约定。\nleft-pad事件\nString.repeat()方法 （O(n)）\n按位与降低算法复杂度（O(n) -&gt; O(logn)）(mdn上的polyfill实现)\n\n代码编写要根据场景，不要对过度的优化设计\n交通灯\n回调地狱\nconst traffic = document.getElementById('traffic');\n\n(function reset() &#123;\n  traffic.className = 's1';\n  \n  setTimeout(() => &#123;\n    traffic.className = 's2';\n    setTimeout(() => &#123;\n      traffic.className = 's3';\n      setTimeout(reset, 1000)\n    &#125;, 1000)\n  &#125;, 1000)\n&#125;)();\n状态机思想\nconst traffic = document.getElementById('traffic');\n\nfunction poll(...fnList) &#123;\n  let stateIndex = 0;\n  \n  return funtion(...args) &#123;\n    let fn = fnList[stateIndex++ % fnList.length];\n    \n    return fn.apply(this, args);\n  &#125;\n&#125;\n\nfunction setState(state) &#123;\n  traffic.className = state;\n&#125;\n\nlet trafficStatePoll = poll(\n\tsetState.bind(nullm 'wait');\n  setState.bind(nullm 'stop');\n\tsetState.bind(nullm 'pass');\n)\n\nsetInterval(trafficStatePoll, 2000);\nasync、await常规做法\nconst traffic = document.getElementById('traffic'); \nfunction wait(time)&#123; \n    return new Promise(resolve => setTimeout(resolve,time)) \n&#125; \n\nfunction setState(state)&#123; \n    traffic.className = state;\n&#125; \n\nasync function start()&#123; \n    while(1)&#123; \n        setState('wait'); \n        await wait(1000); \n        setState('stop'); \n        await wait(3000); \n        setState('pass'); \n        await wait(3000);\n    &#125; \n&#125; \n\nstart();\n\n判断是否是4的幂\n常规操作\nconst isPowerOfFour = (num) => &#123; \n    num = parseInt(num); \n    while(num > 1)&#123; \n        if(num % 4) return false; \n        num /= 4; \n    &#125; \n    return true；\n&#125;\n按位与\nconst isPowerOfFour = (num) => &#123;\n    num = parseInt(num);\n    return num > 0 &amp;&amp;\n           (num &amp; (num-1)) === 0 &amp;&amp;\n           (num &amp; 0XAAAAAAAA) === 0;\n&#125;\n正则\nconst isPowerOfFour = (num) => &#123;\n    num = parseInt(num).toString(2);\n    return /^1(?:00)*$/.test(num);\n&#125;\n\n洗牌\n错误示例\n\n看似可以正确洗牌，但实际上较小的牌放到前面的概率更大，较大的的牌放到后面的概率更大\nconst cards = [0,1,2,3,4,5,6,7,8,9];\nconst shuffle = (cards) => &#123;\n    return [...cards].sort(() => &#123; Math.random() > 0.5 ? -1 : 1 &#125;);\n&#125;\n\n\n正确示例\n\nconst cards = [0,1,2,3,4,5,6,7,8,9]; \nfunction *draw(cards)&#123; \n    const c = [...cards]; \n    for(let i = c.length ; i > 0 ; i--)&#123; \n        const pIdx = Math.floor(Math.random() * i);\n        [c[pIdx],c[i - 1]] = [c[i - 1],c[pIdx]]; \n        yield c[i - 1];\n    &#125; \n    return c; \n&#125;\n\n分红包\n类似于切蛋糕，取最大的继续切分，得出的结果会比较平均\n\nfunction generate(amount,count)&#123; \n    let ret = [amount]; \n    while(count > 1)&#123; \n        // 挑出最大的进行切分 \n        let cake = Math.max(...ret), \n        idx = ret.indexOf(cake), \n              part = 1 + Math.floor((cake / 2) * Math.random()), \n              rest = cake - part; \n        ret.splice(idx,1,part,rest); \n        count --; \n    &#125; \n    return ret; \n&#125;\n\n\n随机性较大，可能会有较大的红包出现\n\nfunction *draw(cards)&#123; \n    const c = [...cards]; \n    for(let i = c.length ; i > 0 ; i --)&#123; \n        const pIdx = Math.floor(Math.random()*i); \n        [c[pIdx],c[i-1]] = [c[i - 1],c[pIdx]]; \n        yield c[i-1] \n    &#125; \n    return c;\n&#125; \n\nfunction generate(amount,count)&#123; \n    if(count &lt;= 1) return [amount]; \n    const cards = Array(amount - 1).fill(null).map((_,i) => i+1); \n    const pick = draw(cards); \n    const result = []; \n    for(let i = 0 ; i &lt; count; i++)&#123; \n        result.push(pick.next().value);\n    &#125; \n    result.sort((a,b)=>a-b); \n    for(let i = count - 1 ; i > 0 ; i--)&#123; \n        result[i] = result[i] - result[i - 1];\n    &#125; \n    return result; \n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n文章中的大部分知识点来自 Byte Dance 青训营社区，下面是主要的引用\nhttps://forum.juejin.cn/youthcamp/post/7052254063840198686\nhttps://forum.juejin.cn/youthcamp/post/7054115780656381959?from=1\n","slug":"如何写好JavaScript代码","date":"2022-01-19T15:20:00.000Z","categories_index":"","tags_index":"","author_index":"EVE"},{"id":"4fa07bcbd0aa3f4d5eb9b3a018e120bd","title":"前端开发调试技巧","content":"前端开发调试技巧前端Debug的特点多平台\n浏览器\nHybrid\nNodeJs\n小程序\n桌面GUI\n……\n\n多环境\n本地开发环境\n\n线上生产环境\n\n…….\n\n多工具\nChrome Devtools\n\nCharles\n\nSpy-Debugger \n\nspy-debugger + charles 移动端调试\n\n\nWhistle\n\nvConsole\n\n……\n\n\n多技巧\nConsole\nBreakPoint\nSourceMap\n代理\n……\n\n桌面端环境 Chrome Devtools一般的桌面端应用，或者开发环境下，最常用的当然是Chrome Devtools，浏览器F12或右击审查元素即可打开面板。\n\nElements面板element主要用来动态地修改元素和样式，也能查看事件监听器在代码中的位置。\n\n点击**.cls开启动态修改元素的class**\n点击**:hov**查看伪类激活的效果\nComputed下点击样式里的箭头可以跳转到Styles面板中的css规则\nLayout可以悬停flex和grid布局的容器\nEvent Listeners查看DOM事件监听器在代码中的位置，也可以进行移除\nProperties罗列出DOM上的所有属性\nDOM Breakpoints快速找到修改了某一个DOM元素的Javascript代码\nAccessibiliy跟Web无障碍相关，如aria-label属性\n\nConsole面板\nconsole.log\n\nconsole.warn\n\nconsole.error\n\nconsole.debug\n\nconsole.info\n面板可以选择等级，对日志进行分类：\n\n\nconsole.table\n具象化地展示JSON和数组数据\n\n\n占位符\n给日志添加样式，突出重要的信息，也可以通过background插入图片\n\n%s：字符串占位符\n%o：对象占位符\n%c：样式占位符\n%d：数字占位符\n\n\n\n\nSources面板sources面板包含着项目的完整代码，提供了很多断点调试工具。\n\n从左到右的区域分别是：\n\n页面资源文件目录\n代码预览区域\nDebug工具栏\n断点调试器\n\nBreakpoint和Watch：\n使用关键字debugger或代码预览区域的行号设置断点\n执行到断点处代码暂停执行\n展开Breakpoints可以看到断点列表\n暂停状态下，鼠标hover变量查看值\n在调试器Watch右侧点击 **+**可以添加对变量的监控 \n\nScope和Call Stack：\n展开Scope查看作用域列表（包含闭包）\n展开Call Stack可以查看当前JavaScript代码的调用栈\n\n如何调试压缩后的代码 —— SourceMap前端代码天生具有“开源”属性，如果不经过一定的处理（压缩和变量名替换），则会有安全隐患。通常会使用Webpack之类的工具对项目的源码进行编译打包，变成类似以下的代码。\n\n上面的代码不可阅读，也很难进行调试。Source Map能解决这些问题，关于它可以写多另外一篇文章进行介绍，这里先简单贴出几篇讲解sourcemap的文章，后续我也会进行详尽地学习，整理成笔记。\n\n\n\n\n\n\n\n\n\n\nhttps://juejin.cn/post/6963076475020902436#comment\n\nhttps://juejin.cn/post/6969748500938489892#comment\n\nhttps://cloud.tencent.com/developer/article/1845590\n\n\n有了Source Map，就能在开发环境下进行调试了。当然，线上环境还是不建议开启，而是接入监控系统，如Sentry，将build之后的sourcemap文件部署到内网的监控系统上。\n\nPerformance面板\n从上到下依次是：\n控制面板概览面板\nFPS：每秒帧数\nCPU：处理各个任务花费的时间\nNET：各个请求花费的时间\n\n线程面板\nFrames：帧线程\nMain：主线程，负责执行JavaScript，解析HTML/CSS，完成绘制\nRaster：Raster线程，负责完成某个layer或者某些块（tile）的绘制\n\n统计面板Networks面板展示与网络请求相关的信息，常用于后端接口调试，以及静态资源优化等。\n\n从上到下依次是：\n控制面板过滤面板概览面板Request Table 面板总结面板请求详情面板Application面板能看到本地存储相关的信息。\n\nLocal StorageSession StorageIndexedDBWeb SQLCookie\n\n\n\n移动端H5环境真机调试IOS：\n使用数据线将iPhone与Mac相连\niPhone开启Web检查器（设置 =&gt; Safari =&gt; 高级 =&gt; 开启Web检查器）\niPhone打开要调试的页面\nMac打开Safari调试（菜单栏 =&gt; 开发 =&gt; iPhone设备名 =&gt; 选择调试页面）\n在弹出的Safari Developer Tools中调试\n\n\n\nAndroid：\n使用数据线将手机与电脑相连\n手机进入开发者模式，勾选USB调试，并允许调试\n电脑打开Chrome，在地址栏输入：chrome://inspect/#devices并勾选Discover USB devices选项\n手机允许远程调试，并访问调试页面\n电脑点击inspect按钮\n进入调试页面\n\n代理调试原理\n电脑作为代理服务器\n手机通过HTTP代理连接到电脑\n手机上的请求都经过代理服务器\n\n以Charles为例：\n安装Charles\n查看电脑IP和端口\n将IP、端口输入手机HTTP代理\nCharles允许授权\n使用SwitchHosts软件给Mac电脑配Hosts\n手机访问开发环境界面\n\n\n\n常用工具\nCharles：适合查看、控制网络请求、分析数据\nFiddler：与Charles类似，适合windows平台\nSpy-Debugger：远程调试手机页面、抓包\nWhistle：基于Node实现的跨平台Web调试代理工具\n\n常用开发调试技巧线上即时修改Overrides利用代理解决开发阶段的跨域问题启用本地Source Map小黄鸭调试法\n\n\n\n\n\n\n\n\n\n急速 debug 实战二（浏览器 - 调试线上篇）\n\n","slug":"前端开发调试技巧","date":"2022-01-19T05:42:36.000Z","categories_index":"","tags_index":"","author_index":"EVE"},{"id":"efa091f902e958fe5c4762b87ffa7084","title":"win向mac环境迁移","content":"win 切换到 mac 的环境迁移买不起 mac，在同学的怂恿下装了黑 mac，前前后后折腾了两三天，总算稳定下来，能开始干活了。 mac 的开发体验确实很舒服，类 linux 的 shell 命令，各种好用的安装工具、终端工具等等。这篇文章主要是记录一下从 win 过渡到 mac 过程中一些必要的软件安装过程，方便之后买正统 mac 转换开发环境（万一呢）。\n\n\n环境类git 环境更改默认 gitmac 下自带的git版本比较低，使用homebrew安装升级\n如果没有安装 homebrew，就先去安装下homebrew的国内源——https://gitee.com/cunkai/HomebrewCN\n/bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\"\n\n安装 Git\nbrew install git\n\n看到下面输出时，说明git已经安装完成：\n\n下面一步是改变git的默认指向：\n// 终端中查看git的指向和版本信息\n$ which git\n/usr/bin/git\n$ git --version\ngit version 2.17.2 (Apple Git-113)\n\n接下来我们通过 brew link 将 git 指向我们通过 Homebrew 安装的 git:\n$ brew link git --overwrite\nWarning: Already linked: /usr/local/Cellar/git/2.20.1\nTo relink: brew unlink git &amp;&amp; brew link git\n\n\u0003link 成功后，退出终端后，再次打开。然后查看 git 指向和版本信息。\n$ which git\n/usr/local/bin/git\n$ git --version\ngit version 2.33.0\n\ngit 全局配置检查全局配置：\ngit config --list\n\n设置全局用户信息：\ngit config --global user.name  \"starryeve\" // 这里是全局信息，细分到单个项目还可以再单独设置\ngit config --global user.email \"starryeve.com\"\n\n配置 ssh在管理 Git 项目上，很多时候都是直接使用 https url 克隆到本地，当然也有有些人使用 SSH url 克隆到本地。\n这两种方式的主要区别在于：\n\n使用https url克隆对初学者来说会比较方便，复制https url然后到 git Bash 里面直接用 clone 命令克隆到本地就好了，但是每次 fetch 和 push 代码都需要输入账号和密码，这也是 https 方式的麻烦之处。\n而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外 ssh 默认是每次 fetch 和 push 代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行 fetch 和 push 也可以另外进行设置。\n\n下面主要是讲述如何配置使用 ssh 方式来提交和克隆代码。\n1、先在本地生成秘钥，如果关联多个 github 账号就生成多个秘钥ssh-keygen -t rsa -C “&#x73;&#116;&#x61;&#114;&#x72;&#121;&#x65;&#x76;&#x65;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;“ -f ~/.ssh/id_rsa_my // 我自己的 sshssh-keygen -t rsa -C “&#x73;&#x74;&#x61;&#x72;&#114;&#121;&#x65;&#x76;&#x65;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;“ -f ~/.ssh/id_rsa_com // 公司的 ssh一路回车，使用默认值，成功后在用户主目录下找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。\nopen ～/.ssh             // 打开ssh所在目录\n\n2、查看生成的公钥：\ncat ~/.ssh/id_rsa_my.pub  // 这里会把公钥显示出来，我们把这段内容复制出来。\n\n3、添加公钥到远程仓库:  登陆你的 github 帐户 -&gt; 点击头像，然后点击 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key  然后将复制的公钥内容，粘贴进 Key 文本域内。 title 域，自己随便起个名字，建议与电脑位置或作用相关的名字，今后可能会新增或者删除 ssh，方便了解是用于哪里的。\n4、查看 ssh 文件是否配置成功ssh -T &#103;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;复制代码输出： Hi danygitgit! You’ve successfully authenticated, but GitHub does not provide shell access.设置已经成功了。\n5、修改 git 的 remote url  如果之前添加的是 HTTPS 协议的 github 仓库地址，那么每次 push 或者 pull 仍然需要密码，所以，我们需要将其修改为 ssh 协议的，这样，就不需要这么麻烦了。  那么我们应该怎么办呢？\n6、查看当前的 remote url  首先进入本地仓库，右键 -&gt; Git Bash Heregit remote -v复制代码输出： origin https://github.com/danygitgit/document-library.git (fetch)输出： origin https://github.com/danygitgit/document-library.git (push)复制代码  如果是以上的结果那么说明此项目是使用 https 协议进行访问的（如果地址是 git 开头则表示是 git 协议）\n7、复制远程仓库的 ssh 链接  登陆你的远程仓库，在上面可以看到你的 ssh 协议相应的 url，类似：\n&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;:danygitgit/document-library.git\n复制此 ssh 链接。\n8、修改 git 的 remote url方法有三种：\n修改命令\ngit remote origin set-url [url]复制代码\n先删后加\ngit remote rm origin复制代码git remote add origin [url]复制代码\n直接修改 config 文件\n找到仓库下 .git 文件夹下的 config 文件，打开，可以看到以下内容\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote “origin”] url =github.com/danygitgit/… fetch = +refs/heads/:refs/remotes/origin/[branch “master”] remote = origin merge = refs/heads/master\n将文件中的 url =https://github.com/danygitgit/document-library.git 更改为 url = &#103;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;:danygitgit/document-library.git 即可。  修改后的文件如下\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote “origin”] url = &#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#109;:danygitgit/document-library.git fetch = +refs/heads/:refs/remotes/origin/[branch “master”] remote = origin merge = refs/heads/master\n以后，不管是 push 还是 pull，你都不需要再提交密码了。\nSourcetree 配置 ssh 密钥SourceTree 是一款 git 管理可视化工具，就不需要繁琐的敲打命令行了。个人比较推荐，无论在 windows 环境还是 mac 的 os 环境。\nshell 环境iterm2直接去官网，item2——https://iterm2.com/\noh my zsh官方的下载方案：\nvia curl：\nsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;\n\n复制代码\n\nvia wget：\nsh -c &quot;$(wget -O- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.s\n\n基本上都不能成功，可以先用git 下载 ，再替换 zshrc：\ngit clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh\n\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n\nnode 环境对于前端工程师，node 环境必不可少，一般直接安装 nodejs 即可，这里使用 nvm 来管理 node 版本。nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果是需要管理 Windows 下的 node，官方推荐是使用 nvm 或 nvm-windows 。\n\n\n\n\n\n\n\n\n\nMac 下通过 brew install nvm 所安装的 nvm ，由于安装路径不同，无法正确启用。建议使用 brew uninstall nvm 卸载掉之后，通过 curl 或 wget 安装\n安装 nvm卸载已有的 node/npm：如果之前是在官网下载的 node 安装包，运行后会自动安装在全局目录，其中\nnode 命令在 /usr/local/bin/node ，npm 命令在全局 node_modules 目录中，具体路径为 /usr/local/lib/node_modules/npm\n安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块：\nnpm ls -g --depth&#x3D;0 #查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装\n\nsudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules #删除全局 node_modules 目录\nsudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node #删除 node\ncd  &#x2F;usr&#x2F;local&#x2F;bin &amp;&amp; ls -l | grep &quot;..&#x2F;lib&#x2F;node_modules&#x2F;&quot; | awk &#39;&#123;print $9&#125;&#39;| xargs rm #删除全局 node 模块注册的软链\n\n安装 nvmcurl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.29.0&#x2F;install.sh | bash\n\n\n\n\n\n\n\n\n\n\n这里使用了 curl 安装 nvm 会一直失败，因为总所周之多原因，raw.githubusercontent.com 的域名遭受 dns 污染，使得国内几乎没办法访问。解决办法有很多，这里图省事，直接开代理，详情参考——\n安装 nvm 之后，出现 nvm command not found 的问题。原因是Mac 新版本中终端是 zsh，所以使用 .bash_profile 文件不会生效，需要使用 zsh 的文件才行。\n解决\ncd ~\ntouch .zshrc\n打开 .zshrc 文件\n写入如下代码\n\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\n复制代码\n\n\n保存\n\nsource ~/.zshrc\n\n退出终端，重新打开，使用 nvm 命令即可\n\n\n升级 nvm 的三种方式\n通过 zsh-nvm\n如果你的 shell 用的是zsh，那么你可以安装zsh-nvm，它作为 zsh 的插件，提供了nvm upgrade的命令，而且它会自动帮你配置 nvm 到环境中。这个方案最方便，只要你用zsh就行了，不过zsh-nvm 官方文档表示就算你用bash也是可以支持的。\ngit clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm\n\n下载完再通过vim添加到.zshrc\nplugins+=(zsh-nvm)\n通过 git\nNVM 安装的过程其实就是把 NVM 的代码直接通过 git 拉到~/.nvm目录中。也就是说，它就是标准的 git 托管的目录，那么要想更新就可以直接到这个目录下，并通过 git 更新到最新代码或者某个版本的代码就行了。\n\n重新安装一遍\n再通过curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash重新运行一遍安装脚本就行了，它实际上就是通过 git 再把代码更新到某个版本，原理和 2 是相同的。\n\n\n安装多个 node1. 查看下当前可用的node版本\n   $ nvm ls或者nvm list\n2. 选择合适的版本安装\n   nvm install 10.15.3          &#x2F;&#x2F; 安装指定版本的node，会自动切换到该版本\n   nvm install node             &#x2F;&#x2F; 安装最新稳定版本的node（即current版本）\n3. 查看安装是否成功\n   $ node -v\n4. 更多nvm命令参考\n   nvm ls-remote                &#x2F;&#x2F; 查看服务器上的node的所有可用版本\n   nvm uninstall 10.15.3        &#x2F;&#x2F; 卸载某个版本的node\n   nvm use 10.15.3              &#x2F;&#x2F; 切换到某个版本的node\n   nvm alias LTS 10.15.3        &#x2F;&#x2F; 给某个版本起个别名\n   nvm unalias LTS              &#x2F;&#x2F; 取消别名\n\n安装后要为 shell 设置一个默认 node 版本，不然每次打开都要 use。\nnvm alias default 16.10.0    // 因为我为16.10.0设置了别名，所以用别名和版本都可以\n\n安装 yarn\nMacOS 直接使用脚本\n\ncurl -o- -L https://yarnpkg.com/install.sh | bash\n复制代码\n\n\nHomebrew 方式\n\nbrew install yarn\n\n\nnpm 方式\n\nnpm install -g yarn\n复制代码\n\n查看是否安装成功\nyarn --version\n\n安装 vue-cliVue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了功能齐备的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 Vue CLI 的文档。\n对于 Vue 3，你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli。要升级，你应该需要全局重新安装最新版本的 @vue/cli：\nyarn global add @vue/cli\n# 或\nnpm install -g @vue/cli\n\n然后在 Vue 项目中运行：\nvue upgrade --next\n\n文档类typora写文档，写博客的必备软件——https://typora.io/\npicgo图床，搭配 typora 使用——https://github.com/Molunerfinn/PicGo/releases\n安装之后打开主界面\n\n选择最底下的插件设置，搜索gitee\n\n点击右边的 gitee-uploader 1.1.2 开始安装\n\n\n\n\n\n\n\n\n\n这里注意一下，必须要先安装node.js才能安装插件，没装的自己装一下，然后重启就行。\n注册一个 gitee 账户，创建一个专门用来放图片的仓库，然后按如下配置即可。\n\nhexohexo 是静态网页搭建平台，支持 markdown，平时写文章写博客都很方便。\n安装hexo 需要 node 环境，使用国内 npm 源更容易安装成功。\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ncnpm install hexo-cli -g\n\n安装完成以后，需要初始化一下项目，执行下列命令：\n$ hexo init\n$ npm install\n\n完成以后，项目大概目录就是这样的：\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n\n_config.yml网站的配置信息，可以在此配置大部分的参数。\npackage.json应用程序的信息。\n\n接下来可以在本地启服务来查看一下项目的初始状态：\n$ npm install hexo-server --save\n$ hexo server\n\n效果大概就是下面的样子：\nhexo 上有很多开源的主题，有时间可以慢慢折腾，这里不做介绍。\n部署1、github 上新建一个仓库\n\n登录自己的 github 后，在界面右上角用户信息点击左边的加号，新建一个与用户名字相同的 repository，github 会默认设置成用户的博客：\n设置页面里面有分支选项，如果有 master 分支，会默认成博客的首选代码；\n\n2、将本地搭建好的 hexo 发布到 github 上：\n安装插件：\nnpm install hexo-deployer-git --save\n\n修改网站配置文件_config.yml,添加 deploy 信息：\ndeploy:\n  type: git\n  repo: git@github.com:starryeve&#x2F;starryeve.github.io.git\n  branch: master\n\n上面的 repo 的配置信息，替换成自己的项目名字\n\n3、生成 SSH key:\n按照网上的教程生成 ssh key 的时候是直接 ssh-add,但是失败了，调查问题，发现原因是因为，我是第一次使用 ssh-agent 代理，第一次需要首先执行以下命令，以后就不需要了（具体原来请参考此处链接）：\n$ ssh-agent bash\n\n以上命令回车，启动进程，后再输入命令：\n$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_blog\n\n接下来的操作就跟上面配置 ssh 完全一样了，不过多介绍。\n\n验证是否连接成功：\n$ ssh -T git@github.com\n\n出现下面的语句说明你的 ssh key 已经配置好了\nHi wispyoureyes! You've successfully authenticated, but GitHub does not provide shell access.\n\n\n到这为止，本地跟远程 github 的连接已经建立，在项目中，直接生成静态文件，上传就可以了：\n$ hexo clean  &#x2F;&#x2F;清除缓存文件db.json和已生成的静态文件public\n$ hexo g   &#x2F;&#x2F;生成网站静态文件到默认设置的public文件夹\n$ hexo d   &#x2F;&#x2F;部署网站到设定的仓库\n\n软件工具\n\n\n\n\n\n\n\n\n以下是 mac 必备软件推荐，这里推荐两个 mac 资源网站：xclient、macwk。\n参考链接nvm：https://www.cnblogs.com/kaiye/p/4937191.html\nhttps://juejin.cn/post/6979140141134643236\nhttps://www.jianshu.com/p/045df8e20ebe\nmac 下环境https://juejin.cn/post/6844904167882883085\n","slug":"win向mac环境迁移","date":"2021-10-02T16:22:33.000Z","categories_index":"","tags_index":"","author_index":"EVE"},{"id":"e51132035092c368289183fb10ca1df0","title":"User-Agent的应用场景","content":"\n\n前言这篇文章的来源是朋友面试唯品会时的一个场景题目——如何根据用户的手机型号跳转对应链接并唤起对应厂商的应用商店。问题的关键在于获取用户的设备信息，微信小程序提供的wx.getSystemInfo(Object object)api就能解决这个问题。但面试官问的应该是h5客户端的跳转，浏览器并没有直接提供类似的api可以调用。面试官最后给的解决方案是，使用https的User-Agent。\nUser-Agent介绍User-Agents是https请求头的一个字段，其值为一个特征字符串，用来让网络协议的对端识别发起请求的用户代理软件的相关信息，如应用类型、浏览器、操作系统以及版本号等。\n格式UA并没有一个十分标准的书写格式，所以很多浏览器使用的格式都不相同，有些厂商还将大量的信息塞进UA。\nUser-Agent: &lt;product&gt; &#x2F; &lt;product-version&gt; &lt;comment&gt;\n\n通常，UA的语法包括三部分：\n\n\n产品识别码。\n\n产品版本号。\n\n零个或多个关于组成产品信息的注释。\n\n例子以我本机使用chrome访问mdn为例（如果是移动端想查看UA可以访问https://www.whatismybrowser.com/）\nMozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;93.0.4577.82 Safari&#x2F;537.36\n\n\nMozilla/5.0：表示浏览器兼容Mozilla的通用标志，目前几乎所有浏览器都通用。\n(Windows NT 10.0; Win64; x64：客户端所运行的原生操作系统是NT 10.0版本(并且运行在64位Windows机器上)。\nAppleWebKit/537.36 (KHTML, like Gecko) ：负责在该设备上渲染内容的引擎是AppleWebKit版本537.36 (KHTML，一个开源布局引擎)。\nChrome/93.0.4577.82 ：客户端使用Chrome 93.0.4577.82。\nSafari/537.36：客户端基于Safari/537.36。\n\n\n\n\n\n\n\n\n\n\n一些常见的浏览器UA，也都可以在MDN上查得到：User Agent\n使用：navigator.userAgentnavigator对象下有一个只读的userAgent属性，会返回当前浏览器的User Agent。(navigator对象下包含了许多存储用户信息的成员变量，且都是只读的)\nconsole.log(window.navigator.userAgent) \n// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36\n\n应用场景浏览器检测在做一些页面时，需要针对不同的浏览器处理不同的逻辑，最简单的就是区分pc和移动端的浏览器，或是android 和ios下的浏览器。遇到一些高版本的框架或第三方插件库的代码不支持ie等非现代浏览器等等，就可以通过分析UA，获得其内核做判断。\n前端性能调控环境信息是每个监控系统必备的内容，通过UA能知道用户的设备和运行平台，从而快速定位问题， 解决问题。除此之外，也有很多数据统计平台通过UA分析用户画像。\n\n爬虫程序伪造在工作中进行爬虫网站时，一般网站是不允许被爬虫访问的，经常会需要提供User-Agent。爬取过程中动态更换在User-agent，可以伪装成浏览器的形式。如果不提供User-Agent，会导致爬虫在请求网页时，请求失败。\n手机型号唤起厂商应用商店在H5等移动端页面上，经常会用到一个引导页面，点击按钮跳转下载链接。通常页面会自动判断手机，iOS跳转AppStore，Android直接跳转下载链接或者对应的应用商店页面。引导页也叫做落地页，承担着引流的职责。引流有两种形式，也可以称之为唤端的定义：\n\n引导已下载用户打开APP。\n引导未下载用户下载APP。\n\n\n\n\n\n\n\n\n\n\nhttps://juejin.cn/post/6844903664155525127  https://juejin.cn/post/6844903951771369479  https://cloud.tencent.com/developer/article/1537372  https://sq.sf.163.com/blog/article/158315832059072512\n避免CDN为PC端缓存移动端页面如果 PC 端和移动端是一套代码则不会出现这个问题。「这个问题出现在 PC 端和移动端是两套代码，却共用一个域名。」\n使用 nginx 配置如下，根据 UA 判断是否移动端，而走不同的逻辑 (判断UA是否移动端容易出问题)\nlocation / &#123;\n    // 默认 PC 端\n    root /usr/local/website/web;\n    \n    # 判断 UA，访问移动端\n    if ( $http_user_agent ~* \"(Android|webOS|iPhone|iPad|BlackBerry)\" )&#123;\n        root /usr/local/website/mobile;\n    &#125;\n \n    index index.html index.htm;\n&#125;\n\n解决方案通常使用 Vary 响应头，来控制 CDN 对不同请求头的缓存。\n「此处可以使用 Vary: User-Agent ，代表如果 User-Agent 不一样，则重新发起请求，而非从缓存中读取页面」\nVary: User-Agent\n\n当然，User-Agent 实在过多，此时缓存失效就会过多。\n\n\n\n\n\n\n\n\n\nhttps://cloud.tencent.com/developer/article/1662201\n。。。\n总结User-Agent是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。核心作用就是让被访问的站点知道用户的相关信息，从而提供不同的布局渲染或特殊响应。在用户环境差别巨大的移动端领域，使用场景尤为广泛。\n参考链接\n\n\n\n\n\n\n\n\n Mozilla5.0  history of the browser  user-agent  浏览器UserAgent的趣味史\n","slug":"user-agent是什么？有哪些应用场景？","date":"2021-09-28T08:00:53.000Z","categories_index":"","tags_index":"","author_index":"EVE"},{"id":"e2cb4e89611544cf3c6b12db41ef12fa","title":"git工作流程","content":"git流程\ngit clone 克隆远程资源到本地目录，作为工作区\n在工作区上修改文件\n每次修改前，先切换master主分支，使用git pull拉取远程资源，merge合并到本地开发分支，以更新本地文件\n本地修改后，通过git status查看文件状态，使用git add添加文件到暂存区\ngit commit将改动从暂存区添加到当前本地仓库\ngit push 将修改从本地仓库推送到远端仓库\n\n\n分支操作\n查看分支，-a查看远程：\ngit branch -a\n\n创建分支，-b创建分支后，切换到新的分支工作：\ngit checkout -b ean\n\n提交本地分支到远程仓库：\ngit push origin ean \n\n合并分支：\ngit checkout master\ngit merge dev\n\n处理冲突：\n\n删除远程分支：\ngit push --delete origin dev\n\n\nstash操作(只能暂存已跟踪的，不能暂存新添加的)应用场景：\n当正在dev分支上开发某个模块时，项目中出现了一个bug，需要紧急修复，而正在开发的内容只是完成一半，还不想提交，这时就可以使用git stashs将修改的内容保存到堆栈区，切换hotfix分支进行bug修复。修复完成后，再切回到dev，从堆栈中恢复刚刚保存的内容。\n由于疏忽，本应该在dev分支上开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存到堆栈中，切回到dev，再次恢复内容即可。\n\n命令：\ngit stash\n能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录\n\ngit stash save\n作用等同于git stash，区别是可以加一些注释\n\ngit stash list \n查看当前stash中的内容\n\ngit stash pop\n将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。注：该命令将堆栈中最近保存的内容删除（先进后出）\n\ngit stash apply\n将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。\n\ngit stash drop + 名称\n从堆栈中移除某个指定的stash\n\ngit stash clear\n清除堆栈中的所有 内容\n\ngit stash show\n查看堆栈中最新保存的stash和当前目录的差异\n\ngit stash branch从最新的stash创建分支。应用场景：当储藏了部分工作，暂时不去理会，继续在当前分支进行开发，后续想将stash中的内容恢复到当前工作目录时，如果是针对同一个文件的修改（即便不是同行数据），那么可能会发生冲突，恢复失败，这里通过创建新的分支来解决。可以用于解决stash中的内容和当前目录的内容发生冲突的情景。发生冲突时，需手动解决冲突。\n\n\n回滚操作回滚场景：仅在工作区修改时当文件在工作区修改，还没有提交到暂存区和本地仓库时，可以用 git checkout -- 文件名 来回滚这部分修改。不过需要特别留意的是这些改动没有提交到 Git 仓库，Git 无法追踪其历史，一旦回滚就直接丢弃了。\n回滚场景：已添加到暂存区时即执行过 git add 添加到暂存区，但还没 commit，这时可以用 git reset HEAD 文件名 回滚。 回滚后工作区会保留该文件的改动，可重新编辑再提交，或者 git checkout -- 文件名 彻底丢弃修改。\n回滚场景：已 commit，但还没有 push 时即已经提交到本地代码库了，不过还没有 push 到远端。这时候可用 git reset 命令，命令格式为：\ngit reset &lt;要回滚到的 commit&gt;\ngit reset 默认会将被丢弃的记录所改动的文件保留在工作区中，以便重新编辑和再提交。加上 --hard 选项则不保留这部分内容，需谨慎使用。\n\ngit reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可\nvscode可视化git插件：\ngitlens\n\n","slug":"git工作流程","date":"2021-08-07T08:57:12.000Z","categories_index":"git","tags_index":"git","author_index":"EVE"},{"id":"4671e4a4ddc838dd69dd6aa254700d36","title":"webpack5搭建vue3环境","content":"使用webpack5搭建vue3环境前言平时项目开发，从稳定性和易用性的角度，一般很少从头到尾搭建环境，大多数是采用以下的方法：\n\n用官方脚手架vue-cli快速搭建项目\n在别人搭建好的项目基础上开发\n\n虽然能快速上手，但不利用项目把控能力的培养。无论是从面试的角度还是从问题排查的角度，不了解基础的配置，都是百害无一利的。本文从搭建vue 3.x开发环境出发，学习一下webpack 5。\n基本初始化项目先抛开vue，使用webpack搭建一个初步的工程化项目。首先，创建一个文件夹，初始化项目：\nmkdir vue3-webpack-demo\ncd vue3-webpack-demo\n\nnpm init -y // -y省去敲回车的步骤\n\n得到一个只有 package.json 文件的项目，接下来安装 webpack 和 webpack-cli：\nnpm install webpack webpack-cli -D\n\n\n\n\n\n\n\n\n\n\nwebpack-cli 是执行 webpack 的工具。4.x 版本以后，剥离出了 webpack-cli 。\n在根目录下添加src文件夹，在src内新建main.js；在根目录下新建index.html和webpack.config.js:\n\nwebpack.config.js添加一些内容：\nmodule.exports = &#123;\n  mode: \"development\", // 环境， \"production\" | \"development\" | \"none\"\n  entry: resolve(__dirname, './src/main.js'), // dirname返回当前路径的绝对路径\n  output: &#123;\n    path: resolve(__dirname, 'dist')\n  &#125;,\n  filename: 'bundle.js'\n&#125;\n\nentry指示webpack构建依赖的起始模块，从入口起点进入后，webpack会找出所有与入口起点（直接或间接）的依赖项进行处理，最后输出到dist文件夹下的bundle.js文件中。\n\n\n\n\n\n\n\n\n\n以上只是最简化的配置，实际上入口可以有多个，output属性也还有更多可配置的特性\n修改 package.json 的 scripts 属性：\n\"scripts\": &#123; \n    \"dev\": \"webpack --config ./webpack.config.js\" \n&#125;\n\n命令行键入npm run dev:\n\n打包成功，目录下多了dist：\n\n添加html模板打包成功后，还需要在html文件中引入打包好的js文件，这个操作当然不能每次都由我们自己手动引入。\n添加html-webpack-plugin插件：\nnpm install html-webpack-plugin -D\n\n单文件入口修改webpack-config.js:\nconst &#123; resolve &#125; = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = &#123;\n  mode: 'development',\n  entry: resolve(__dirname, '../src/main.js'), // dirname返回当前路径的绝对路径\n  output: &#123;\n    path: resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: resolve(__dirname, '../public/index.html'), // 要使用的html模板\n      filename: 'index.html' //打包后输出的文件名\n    &#125;)\n  ]\n&#125;\n\n重新运行命令打包，生成了一个html文件：\n\n\n\n\n\n\n\n\n\n\n html-webpack-plugin 插件详细的配置项见请 Github官网 。\n多入口文件很多单页面项目都只有一个index.html作为模板入口，但有时候也需要多个入口文件，这时候就可以通过生成多个html-webpack-plugin实例实现。\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = &#123;\n    mode:'development', \n    entry: &#123;\n    \tmain:path.resolve(__dirname,'../src/main.js'),\n      header:path.resolve(__dirname,'../src/header.js')\n  \t&#125;, \n    output: &#123;\n      filename: '[name].[hash:8].js',      // 打包后的文件名称\n      path: path.resolve(__dirname,'../dist')  // 打包后的目录\n    &#125;,\n    plugins:[\n      new HtmlWebpackPlugin(&#123;\n        template:path.resolve(__dirname,'../public/index.html'),\n        filename:'index.html',\n        chunks:['main'] // 与入口文件对应的模块名\n      &#125;),\n      new HtmlWebpackPlugin(&#123;\n        template:path.resolve(__dirname,'../public/header.html'),\n        filename:'header.html',\n        chunks:['header'] // 与入口文件对应的模块名\n      &#125;),\t\t\t\t\n    ]\n&#125;\n\n再次运行打包命令，可以看到项目有了多个html模板：\n\n清除打包残留项每次执行npm run dev，dist文件夹里都会残留上次打包的文件\n\n使用clean-webpack-plugin进行清除：\nconst &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin')\nmodule.exports = &#123;\n    // ...省略其他配置\n    plugins:[new CleanWebpackPlugin()]\n&#125;\n\n解析css基本的css目前为止项目的入口文件都是index.js，我们在里面引入css文件\n// index.js// ...import './assets/index.scss'\n\n解析css用到的两个loader是style-loader和css-loader\nnpn i -D style-loader css-loader\n\n使用预处理器这里使用了scss预处理器，还需要安装sass和sass-oader\nnpm i -D sass sass-loader node-sass\n\n// webpack.config.js\nmodule.exports = &#123;    \n  // ...    \n  module:&#123;      \n    rules:[     \n      &#123;        \n        test:/\\.css$/,  \n        use:['style-loader','css-loader'] // 从右向左解析原则    \n      &#125;,        \n      &#123;         \n        test:/\\.s[ca]ss$/,       \n       \tuse:['style-loader','css-loader','sass-loader'] // 从右向左解析原则    \n      &#125;      \n    ]    \n  &#125;&#125; \n\n添加浏览器前缀当一个新的css属性还未成为标准时，浏览器厂商们有时会给这些属性添加自家的私有前缀，允许开发者使用这些新的特性进行试验，同时防止他们的试验代码被依赖，在标准化过程中破坏web开发者的代码。（w3c制定标准是很慢的，而浏览器厂商市场推广时间紧）。\u0003\n-webkit-transition: all 4s ease; &#x2F;&#x2F; 谷歌，Safari，新版Opera，以及几乎所有iOS系统中的浏览器（包括iOS的火狐浏览器；基本上所有基于Webkit内核的浏览器）-moz-transition: all 4s ease; &#x2F;&#x2F; 火狐-ms-transition: all 4s ease; &#x2F;&#x2F; IE和Edge-o-transition: all 4s ease; &#x2F;&#x2F; 旧版Operatransition: all 4s ease; \n\n\n\n\n\n\n\n\n\n\n上面代码示例的是一些比较老的版本浏览器内核，实际上现在有很多已经发生了变化\n使用postcss-loader和autoprefixer添加前缀：\nnpm i -D postcss-loader autoprefixer\n\n// webpack.config.js\nmodule.exports = &#123;\t\n  // ...    \n  module:&#123;   \n    rules:[ \n      &#123;    \n        test:/\\.s[ac]ss$/,     \n        use:['style-loader','css-loader','postcss-loader','sass-loader'] // 从右向左解析原则           \n      &#125;        \n    ]    \n &#125;&#125; \n\n还需要引入autoprefixer才能生效，两种方式：\n\n在项目根目录下创建postcss.config.js:\n// postcss.config.js\nmodule.exports = &#123;\t\n  plugins: [require('autoprefixer')]\n&#125;\n在webpack.config.js里面配置：\n// webpack.config.js\nmodule.exports = &#123;\n  //...省略其他配置   \n  module:&#123;        \n    rules:[\n      &#123;   \n      \ttest:/\\.s[ca]ss$/,   \n        use:['style-loader','css-loader',\n             &#123;                \n               \tloader:'postcss-loader',\n              \toptions:&#123;            \n                  plugins:[require('autoprefixer')]     \n              \t&#125;            \n             &#125;,'sass-loader'\n            ] // 从右向左解析原则    \n      &#125;]    \n  &#125;\n&#125;\n\n重新打包运行，发现并没有成功添加上前缀：\n\n其实很简单，autoprefixer插件是通过识别browserslist中指定的浏览器来添加前缀的，而项目中暂时还没有browserslist\n解决方式：\n\n在package.json中添加：\n// package.json&#123;\nbrowserslist: [\t\n  \"> 1%\",\t\t\n  \"last 2 versions\",\t\n  \"not ie &lt; 10\"\t]\n&#125;\n根目录下添加.browserslist:\n&#x2F;&#x2F; .browserslist\n&gt; 1%\nlast 2 versionsnot \nie &lt;&#x3D; 10\n\n再次尝试，问题解决\n\n\n\n\n\n\n\n\n\n\n参考链接：https://github.com/postcss/autoprefixer\n拆分css上述打包后的css代码都内嵌在html文件的style中，可以使用插件将css代码拆分出来以外链的形式引入\nnpm i -D mini-css-extract-plugin\n\n\n\n\n\n\n\n\n\n\nwebpack 4之前，使用的是extract-text-webpack-plugin，4之后，官方推荐使用mini-css-extract-plugin插件来打包css文件，关于两者的比较可查阅mini-css-extract-plugin\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nmodule.exports = &#123; \n  //...省略其他配置 \n  module: &#123;  \n    rules: [  \n      &#123;      \n        test: /\\.s[ac]ss$/,  \n        use: [  \n          MiniCssExtractPlugin.loader,  \n          \"style-loader\",  \n          'css-loader',  \n          'sass-loader'  \n        ],      \n      &#125;    \n    ]  \n  &#125;,  \n  plugins: [ \n    new MiniCssExtractPlugin(\n      &#123;      \n        filename: \"[name].[hash:8].css\", \n        chunkFilename: \"[id].css\",   \n      &#125;\n    )  \n  ]\n&#125;\n\n打包过程中抛了个错，原因是style-loader会与其他试图分离css为外链文件的插件产生冲突，这也好理解，因为style-loader的作用是把css添加到html头部的&lt;style&gt;&lt;/style&gt;里面\n\n解决方法：移除style-loader即可\n\n\n\n\n\n\n\n\n\n\n参考链接：https://flutterq.com/module-build-failed-from-node_modules-mini-css-extract-plugin-dist-loader-js-referenceerror-document-is-not-defined/\n拆分多个css上面用到的mini-css-extract-plugin会将所有的css样式合并为一个css文件。如果你想拆分为一一对应的多个css文件,我们需要使用到extract-text-webpack-plugin，而目前mini-css-extract-plugin还不支持此功能。需要安装@next版本的extract-text-webpack-plugin，之后用到的时候再来补充吧\n配置babelECMAScript新特性用起来很爽，但有些浏览量偏偏就不支持（指名道姓IE），所以就需要使用babel进行代码编译，转化成向下兼容的ECMAScript版本\n语法转换安装一下babel的几个依赖：\nnpm install -D @babel/core @babel/preset-env babel-loader\n\n\n@babel/core： babel 的核心库\n@babel/preset-env：取代了 es2015 es2016 es2017 ，通过配置浏览器版本的形式，将编译的主动权，交给了插件\nbabel-loader： webpack 的 loader 插件，用于编译代码，转化成浏览器读得懂的代码\n\n\n\n\n\n\n\n\n\n\n注意 babel-loader与babel-core的版本对应关系\n\nbabel-loader 8.x 对应babel-core 7.x\nbabel-loader 7.x 对应babel-core 6.x\n\n安装完成，webpack.config.js添加如下代码：\nmodule: &#123;    \n  rules: [  \n    &#123;        \n      test: /\\.js$/,  \n      exclude: '/node_modules', // 忽略依赖  \n      loader: 'babel-loader', \n      options: &#123;        \n        presets: ['@babel/preset-env']  \n      &#125;      \n    &#125;    \n  ]\n&#125;,\n\nAPI转换上面的babel-laoder只会将ES6/7/8语法转换为ES5语法，并不会处理新的API转换，如Promise，Generator，Set，Map，Proxy等等，需借助babel-polyfill\nnpm i -D @babel/polyfill\n\n这个时候，再去看打包后的bundle.js文件，会发现行数变得更多了，证明添加了polyfill之后确实对API进行了转换        \n解析资源模块资源模块资源模块(asset module)是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 loader。\n在webpack5之前，通常使用：\n\nraw-loader 将文件导入为字符串\nurl-loader 将文件作为 data URI 内联到 bundle 中\nfile-loader 将文件发送到输出目录\n\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：\n\nasset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\nasset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\nasset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\nasset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n\n// webpack.config.js\nmodule.exports = &#123;\n\t\t....\n    module:&#123;        \n      rules:[\n  \t\t....\n        &#123;\n          test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n          include: path.resolve(__dirname, \"../src/assets\"),\n          type: \"asset/resource\"  \n        &#125;,\n      ]    \n    &#125;\n&#125;\n\n所有引入的 .png 文件都将被发送到输出目录，并且其路径将被注入到 bundle 中。\n// main.js\nimport mainImage from './images/main.png';\n\nimg.src = mainImage; // '/dist/151cfcfa1bd74779aadb.png'\n\n自定义输出文件名默认情况下，asset/resource 模块以 [hash][ext][query] 文件名发送到输出目录。\n可以通过在 webpack 配置中设置 output.assetModuleFilename 来修改此模板字符串：\n// webpack.config.js\nmodule.exports = &#123;\n\t\t....\n    output: &#123;\n      filename: 'js/[name].[hash:8].js',      // 打包后的文件名称\n      path: path.resolve(__dirname,'../dist'),  // 打包后的目录\n      assetModuleFilename: 'images/[hash][ext][query]',\n    &#125;,\n &#125;\n\n另一种自定义输出文件名的方式是，将某些资源发送到指定目录：\nconst path = require('path');\nmodule.exports = &#123;\n  module: &#123;\n    rules: [\n        &#123;\n          test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n          include: path.resolve(__dirname, \"../src/assets\"),\n          type: \"asset/resource\"  \n          generator: &#123;\n          \tfilename: 'static/[hash][ext][query]'\n        \t&#125;\n        &#125;\n    ]\n  &#125;,\n&#125;;\n\n使用此配置，所有 html 文件都将被发送到输出目录中的 static 目录中。\n通用资源类型按照默认条件，自动地在 resource 和 inline 之间进行选择：小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型，也可以手动指定。\n// webpack.config.js\nconst path = require('path');\n\nmodule.exports = &#123;\n\t....\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n        include: path.resolve(__dirname, \"../src/assets\"),\n        type: 'asset',\n        generator: &#123;\n           filename: 'static/[hash][ext][query]'\n        &#125;\n        parser: &#123;\n          dataUrlCondition: &#123;\n            maxSize: 4 * 1024 // 4kb\n         &#125;\n      &#125;\n    ]\n  &#125;\n&#125;;\n\n配置devServer使用vue-cli开发的时候，只要代码一保存，就会重新打包构建，自动刷新页面，使用的就是webpack-dev-serve\nnpm install webpack-dev-server -D\n\n在 webpack.config.js 下添加如下配置：\ndevServer: &#123;    \n  contentBase: resolve(__dirname, './dist'),\n  port: 8080,   \n  publicPath: '/'  \n&#125;\n\n修改 package.json 运行脚本：\n\"scripts\": &#123;\t\"dev\": \"webpack serve --progress --config ./webpack.config.js --open\"&#125;\n\n\n\n\n\n\n\n\n\n\nwebpack-cli4之前，使用的是webpack-dev-server\n重新打包运行，可以看到此时静态资源bundle.js运行在浏览器的内存里，可以进行热更新：\n\nwebpack5和webpack-cli4环境下，当package.json存在browserslist时，热更新会失效\n这是因为webpack5默认的target是web或browserslist，取决于是否有browserslist配置项，而只有为webHMR才有效。\n这其实是webpack-dev-server遗留的一个bug，通过升级webpack-dev-server值next版本，即对接webpack5的v4版本，也能解决问题。\n\n\n\n\n\n\n\n\n\n\n参考链接：\n\nhttps://webpack.js.org/configuration/target/#target\n\nhttps://github.com/webpack/webpack-dev-server/issues/2758\n\nwebpack-dev-server\n\n\n集成typescriptvue3的源码也是用typescript进行重写的，无论是代码提示还是项目贴合，都是引入ts的很好的理由。\n安装依赖npm install typescript ts-loader -D\n\n修改webpack.config.js// webpack.config.js\nmodule.exports = &#123;\n  // ...\t\n  modules: &#123;\t\n    // ...    \n    test: /\\.ts$/, \n    use: [&#123;   \n      loader: 'ts-loader',  \n      options: &#123;  \n        appendTsSuffixTo: [/.vue$/]    \n      &#125;    \n    &#125;]\t\n  &#125;,&#125;\n\n初始化tsconfig.jsontsc --init\n\nvue环境识别.vue文件一个.vue文件通常包含三个部分：template，script和style，vue-loader能将.vue文件分割成这三个部分，template部分就通过compiler处理成render和staticRenderFns\n\n安装依赖\n\nnpm install vue@next -Snpm install vue-loader@next @vue/compiler-sfc\n\n\n\n\n\n\n\n\n\n\nvue2.x 安装的是vue-loader和vue-template-compiler\n\n修改webpack.config.js:\n\nconst &#123; VueLoaderPlugin &#125; = require('vue-loader/dist/index');\nmodule.exports = &#123;  \n  // ...   \n  module: &#123;    \n    rules: [    \n      &#123;             \n        test: /\\.vue$/,  \n        use: [                \n          'vue-loader'                \n        ]            \n      &#125;        \n    ]    \n  &#125;,    \n  plugins: [ \n    new VueLoaderPlugin()  \n  ]\n&#125;\n\n\n新增App.vue文件\n\n// App.vue\n&lt;template>   \n  &lt;div>      \t\n    &#123;&#123;message&#125;&#125;   \n  &lt;/div>\n&lt;/template>\n&lt;script lang=\"ts\">\n import &#123; defineComponent, ref &#125; from 'vue';\nexport default defineComponent(&#123; \n  setup() &#123;     \n    const message = ref('hello, vue3') \n    return &#123;      \n      message   \n    &#125;    \n  &#125;\n&#125;)\n&lt;/script>\n\n\nindex.js中引入Vue\n\n&#x2F;&#x2F; index.js\nimport &#123; createApp &#125; from &#39;vue&#39;;\nimport App from &#39;.&#x2F;App.vue&#39;;\ncreateApp(App).mount(&#39;#app&#39;)\n\n\n\n\n\n\n\n\n\n\n使用defineComponent 可以在使用 Vue3 的时候获得更好的语法提示\n\n\nhttps://github.com/vuejs/vue-next-webpack-preview/issues/5\n配置ESLint\n依赖安装\n安装eslint\n可以全局安装，也可以只在当前项目安装，这里选择当前\nnpm i -d eslint\n安装解析器\neslint默认使用Espree作为其解析器，可以在配置文件中指定一个不同的解析器，以下解析器与eslint兼容：\n\nEsprima\nBabel-ESLint - 一个对Babel解析器的包装，使其能够与 ESLint 兼容。\n@typescript-eslint/parser - 将 TypeScript 转换成与 estree 兼容的形式，以便在ESLint中使用。\n\n项目中用到了typescript和vue，需要安装@typescript-eslint/parser和eslint-plugin-vue\nnpm i -D @typescript-eslint/parser\n安装扩展规则\n可以在配置文件继承已启用的规则，达到扩展的目的，这里需要安装@typescript-eslint/eslint-plugin和eslint-plugin-vue两个插件，它们提供了一些预设规则\nnpm i -D @typescript-eslint/eslint-plugin eslint-plugin-vue\n\n配置文件详解\n项目目录下新建.eslintrc.js，代码检查的规则都在这里面配置\n// .eslintrc.jsmodule.exports = &#123;\t\t&#125;\t\n添加解析器\n// .eslintrc.jsmodule.exports = &#123;\t\tparser: 'vue-eslint-parset',\t\tparserOptions: &#123;        parser: '@typescript-eslint/parser',        ecmaVersion: 12,        sourceType: 'module',    &#125;,&#125;\t\n\n由于解析器只有一个，用了「vue-eslint-parser」就不能用「@typescript-eslint/parser」。解决方法是，在解析器选项中，再传入一个解析器选项parser。从而在内部处理「@typescript-eslint/parser」，检测&lt;script&gt;中的ts代码\n\necmaVersion： 指定你想要使用的 ECMAScript 版本，默认为5。也可以用使用年份命名的版本号指定为 2015（同 6）等\nsourceType：设置为 “script“ (默认) 或 “module“（如果代码是 ECMAScript 模块)\n\n\n\n\n\n\n\n\n\n\n详细配置参考官网：https://cn.eslint.org/docs/user-guide/configuring#specifying-processor\n\n添加预设规则\n// .eslintrc.jsmodule.exports = &#123;\t // ...\t extends: [      // add more generic rulesets here, such as:      // 'eslint:recommended',      'plugin:vue/vue3-recommended',      'plugin:@typescript-eslint/recommended',    ],&#125;\t\n配置全局变量\n添加eslint 后，一些全局对象会报错，修改.eslintrc.js\nmodule.exports = &#123;\t\t// ...    \"globals\": &#123;        document: true,        window: true    &#125;,&#125;;\n添加启用的规则和错误级别\n遵循【”规则名”: [规则值, 规则配置]】的格式\n\n“off” 或 0 - 关闭规则\n“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n\nmodule.exports = &#123;\t\t// ...    \"rules\": &#123;        \"semi\": 2    &#125;,&#125;;\n\nvs code 代码保存自动修正\n安装eslint插件 \n\n\n修改settings.json\n// settings.json&#123;   \n// ...  \n\"eslint.validate\": [ \n  // eslint执行校验的文件格式    \n  \"javascript\",    \"javascriptreact\",    \"typescript\",    \"html\",    \"vue\"   ],   \t\"editor.codeActionsOnSave\": &#123;\n    // 保存自动按照.eslintrc.js的规则进行代码校验   \t\t\n    \"source.fixAll.eslint\": true,   \n  &#125;,  // ... &#125;\n\n完成了以上的配置，看下效果：\n\n保存后能自动校验并修正：\n\n","slug":"webpack5搭建vue3环境","date":"2021-08-07T08:52:54.000Z","categories_index":"webpack","tags_index":"webpack web前端","author_index":"EVE"},{"id":"43e50756c3c9f1fa16f87b82a098213d","title":"koa的基本使用","content":"koa demo学校期末实践要求做一个管理系统，刚好最近在看 node 后端的东西，就学习一下 koa，了解一下洋葱圈模型的思想和 MVC 架构的应用。\n\n\n一. 安装 koa毕竟是后端服务，类型检测还是有必要上的，就顺便加上了 typescript。没有从零开始搭建，直接用别人搭建好的简易脚手架了。\ngit clone -b start-point https://github.com/tuture-dev/koa-quickstart.git\n\n\n\n\n\n\n\n\n\n\n这里我使用了 package-lock.json 确保所有依赖版本一致，如果你用 yarn 安装依赖出现问题，建议删除 node_modules ，重新用 npm install 安装。\n二. 搭建服务器\n初始化实例 app\n注册相关的中间件（跨域 cors 和请求体解析中间件 bodyParser）\n添加请求处理处理，响应用户请求\n运行服务器\n\n\n\n\n\n\n\n\n\n\nexpress 中的请求处理函数：\nfunction handler(req, res) &#123;\n  res.send(\"Hello Express\");\n&#125;\n\nkoa 中的：\napp.use((ctx) &#x3D;&gt; &#123;\n  ctx.body &#x3D; &quot;Hello Koa&quot;;\n&#125;);\nctx（context）是上下文对象，\n三. 运行服务这里有个 ts 的报错：\nWarning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n\n这个问题涉及 s 的模块化，顺便复习一下：\n\nAMD (Asynchronous Module Definition): 在浏览器中使用，并用 define 函数定义模块；\nCJS (CommonJS): 在 NodeJS 中使用，用 require 和 module.exports 引入和导出模块；\nESM (ES Modules): JavaScript 从 ES6(ES2015) 开始支持的原生模块机制，使用 import 和 export 引入和导出模块；\n\n报错的原因：node 13.2.0 以前不支持 ES Module（当前环境下是 12.18.3）\n解决办法：\n\n升级 node, 直接上官网下载最新版本覆盖\npackage.json 添加 ‘type’: ‘module’\n\n这里是用了 nodeman，所以不会有模块报错的问题\n四. 中间件\n\n\n\n\n\n\n\n\nExpressive middleware for node.js using ES2017 async functions.（通过 ES2017 async 函数编写富有表达力的 Node.js 中间件）\nkoa 只是一个中间件框架，对标的是 express 底层的中间件层，而不包含诸如路由、模板引擎、发送文件等功能\n\n1. 洋葱圈模型\n\nexpress 的中间件：\n\n\n请求（Request）直接依次贯穿各个中间件，最后通过请求处理函数返回响应（Response）\nkoa 的中间件：\n\nKoa 中间件不像 Express 中间件那样在请求通过了之后就完成了自己的使命；相反，中间件的执行清晰地分为两个阶段\n2. 中间件的定义async function middleware(ctx, next) &#123;\n  // 第一阶段\n  await next();\n  // 第二阶段\n&#125;\n\n\nctx：就是 koa context, 贯穿上图所有中间件和请求处理函数的绿色箭头所传递的内容，里面封装了请求体和响应体（和其他属性），常用属性：Context API 文档。\nctx.url; // 相当于 ctx.request.url\nctx.body; // 相当于 ctx.response.body\nctx.status; // 相当于 ctx.response.status\nnext：将控制权转交给下一个中间件，与 express 的 next 函数本质的不同是，返回一个 promise，在这个 Promise 进入完成状态（Fulfilled）后，就会去执行中间件中第二阶段的代码\n\n\n3. 日志记录中间件简单的一个logger，打印每次请求的方法，url，状态码和响应时间\nimport &#123; Context &#125; from &quot;koa&quot;;\n\nexport function logger() &#123;\n  return async (ctx: Context, next: () &#x3D;&gt; Promise&lt;void&gt;) &#x3D;&gt; &#123;\n    const start &#x3D; Date.now();\n    await next();\n    const ms &#x3D; Date.now() - start;\n    console.log(&#96;$&#123;ctx.method&#125; $&#123;ctx.url&#125; $&#123;ctx.status&#125; - $&#123;ms&#125;ms&#96;);\n  &#125;;\n&#125;\n\n此处的 logger 是一个中间件工厂函数（Factory），调用这个工厂函数返回的结果才是真正的 koa 中间件。之所以写成一个工厂函数，是因为我们可以通过给工厂函数传参的方式来更好地控制中间件的行为\n在这个中间件的第一阶段，我们通过 Date.now() 先获取请求进入的时间，然后通过 await next() 让出执行权，等待下游中间件运行结束后，再在第二阶段通过计算 Date.now() 的差值来得出处理请求所用的时间\n五. 路由配置由于 koa 只是一个中间件框架，所以路由的配置需要独立的 npm 包，先安装 @koa/router 及其 ts 类型定义：：\n$ npm install @koa/router\n$ npm install @types/koa__router -D\n\n\n\n\n\n\n\n\n\n\n也可以使用koa-router，但koa-router目前处于几乎无人维护的状态，所以使用维护更积极的 Fork 版本 @koa/router\n1. 路由规划\nGET /users ：查询所有的用户\nGET /users/:id ：查询单个用户\nPUT /users/:id ：更新单个用户\nDELETE /users/:id ：删除单个用户\nPOST /users/login ：登录（获取 JWT Token）\nPOST /users/register ：注册用户\n\n2. 实现 Controller创建controllers目录，存放控制器相关的代码\nAuthController:\n&#x2F;&#x2F; src&#x2F;controllers&#x2F;auth.ts\nimport &#123; Context &#125; from &quot;koa&quot;;\n\nexport default class AuthController &#123;\n  public static async login(ctx: Context) &#123;\n    ctx.body &#x3D; &quot;Login controller&quot;;\n  &#125;\n\n  public static async register(ctx: Context) &#123;\n    ctx.body &#x3D; &quot;Register controller&quot;;\n  &#125;\n&#125;\n\n`UserController``:\nimport &#123; Context &#125; from 'koa'\n\nexport default class UserController &#123;\n  public static async listUsers (ctx: Context) &#123;\n    ctx.body = 'ListUsers controller';\n  &#125;\n\n  public static async showUserDetail (ctx: Context) &#123;\n    ctx.body = `ShowUserDetail controller with ID = $&#123;ctx.params.id&#125;`;\n  &#125;\n\n  public static async updateUser (ctx: Context) &#123;\n    ctx.body = `UpdateUser controller with ID = $&#123;ctx.params.id&#125;`\n  &#125;\nf\n\n  public static async deleteUser (ctx: Context) &#123;\n    ctx.body = `DeleteUser controller with ID = $&#123;ctx.params.id&#125;`;\n  &#125;\n&#125;\n\n3. 实现路由创建 routers.ts，把控制器挂载到对应的路由上面：\n&#x2F;&#x2F; src&#x2F;routes.ts\nimport Router from &quot;@koa&#x2F;router&quot;;\n\nimport AuthController from &quot;.&#x2F;controllers&#x2F;auth&quot;;\nimport UserController from &quot;.&#x2F;controllers&#x2F;user&quot;;\n\nconst router &#x3D; new Router();\n\n&#x2F;&#x2F; auth 相关的路由\nrouter.post(&quot;&#x2F;auth&#x2F;login&quot;, AuthController.login);\nrouter.post(&quot;&#x2F;auth&#x2F;register&quot;, AuthController.register);\n\n&#x2F;&#x2F; users 相关的路由\nrouter.get(&quot;&#x2F;users&quot;, UserController.listUsers);\nrouter.get(&quot;&#x2F;users&#x2F;:id&quot;, UserController.showUserDetail);\nrouter.put(&quot;&#x2F;users&#x2F;:id&quot;, UserController.updateUser);\nrouter.delete(&quot;&#x2F;users&#x2F;:id&quot;, UserController.deleteUser);\n\nexport default router;\n\n这里导入@koa/router 报了个错：\n\n原因是 ts 文件引入第三方的模块缺少类型声明，解决方案有两种：\n\n自己编写类型声明文件\n安装官方提供的.d.ts\n\n4. 注册路由将 router 注册为中间件\napp.use(router.routes()).use(router.allowedMethods());\n\n这里我们调用 router 对象的 routes 方法获取到对应的 Koa 中间件，还调用了 allowedMethods 方法注册了 HTTP 方法检测的中间件，这样当用户通过不正确的 HTTP 方法访问 API 时，就会自动返回 405 Method Not Allowed 状态码\n六. 接入 MySql1. 运行数据库安装、运行 MySql，通过命令行连接数据库：\nmysql -u root -p\n\n输入预先设置好的根账户密码，进入 MySql 的交互式执行客户端，运行以下命令：\n--- 创建数据库\nCREATE DATABASE koa;\n\n--- 创建用户并授予权限\nCREATE USER 'user'@'localhost' IDENTIFIED BY 'pass';\nGRANT ALL PRIVILEGES ON koa.* TO 'user'@'localhost';\n\n--- 处理 MySQL 8.0 版本的认证协议问题\nALTER USER 'user'@'localhost' IDENTIFIED WITH mysql_native_password BY 'pass';\nflush privileges;\n\n2. TypeORM 的配置和连接安装相关的 npm 包，分别是 MySql 驱动，TypeORM 以及 reflect-metadata（反射 api 库，用于 TypeORM 推断模型的元数据）\nnpm install mysql typeorm reflect-metadata\n\n然后在项目根目录下创建ormconfig.json，TypeORM 会读取这个数据库配置进行连接：\n// ormconfig.json\n&#123;\n  \"type\": \"mysql\",\n  \"host\": \"localhost\",\n  \"port\": 3306,\n  \"username\": \"user\",\n  \"password\": \"pass\",\n  \"database\": \"koa\",\n  \"synchronize\": true, // 设为true能够让每次修改模型定义后能自动同步到数据库（就是其他ORM的自动数据迁移）\n  \"entities\": [\"src/entity/*.ts\"], // 定义了模型文件的路径，下文创建\n  \"cli\": &#123;\n    \"entitiesDir\": \"src/entity\"\n  &#125;\n&#125;\n\n3. 连接数据库修改 src/server.ts：\n&#x2F;&#x2F; src&#x2F;server.ts\nimport Koa from &quot;koa&quot;;\nimport cors from &quot;@koa&#x2F;cors&quot;;\nimport bodyParser from &quot;koa-bodyparser&quot;;\nimport &#123; createConnection &#125; from &quot;typeorm&quot;;\nimport &quot;reflect-metadata&quot;;\n\nimport router from &quot;.&#x2F;routes&quot;;\nimport &#123; logger &#125; from &quot;.&#x2F;logger&quot;;\n\ncreateConnection()\n  .then(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 初始化 Koa 应用实例\n    const app &#x3D; new Koa();\n\n    &#x2F;&#x2F; 注册中间件\n    app.use(logger());\n    app.use(cors());\n    app.use(bodyParser());\n\n    &#x2F;&#x2F; 响应用户请求\n    app.use(router.routes()).use(router.allowedMethods());\n\n    &#x2F;&#x2F; 运行服务器\n    app.listen(3000);\n  &#125;)\n  .catch((err: string) &#x3D;&gt; console.log(&quot;TypeORM connection error:&quot;, err));\n\n4. 创建数据模型定义在src下创建entity目录，用于存放数据模型定义文件，创建 user.ts，代表用户模型：\n&#x2F;&#x2F; src&#x2F;entity&#x2F;user.ts\nimport &#123; Entity, Column, PrimaryGeneratedColumn &#125; from &quot;typeorm&quot;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column(&#123; select: false &#125;)\n  password: string;\n\n  @Column()\n  email: string;\n&#125;\n\ntypeorm使用装饰器将user类映射到数据库中的表：\n\nEntity：用于装饰整个类，使其变成一个数据库模型\nColumn：装饰类的某个属性，使其对应于数据库表中的一列，可提供一系列选项参数，如select: false，表示该字段在查询时默认不被选中\nPrimaryGenerateColumn：装饰主列，值自动生成\n\n\n\n\n\n\n\n\n\n\ntypeorm 的装饰器定义和使用：装饰器文档\n完成以上配置，就可以在 Controller 中进行数据的增删改查了。\n5. 实现 Controller 的逻辑：5.1 实现 UserController：&#x2F;&#x2F; src&#x2F;controllers&#x2F;user.ts\nimport &#123; Context &#125; from &quot;koa&quot;;\nimport &#123; getManager &#125; from &quot;typeorm&quot;;\n\nimport &#123; User &#125; from &quot;..&#x2F;entity&#x2F;user&quot;;\n\nexport default class UserController &#123;\n  public static async listUsers(ctx: Context) &#123;\n    const userRepository &#x3D; getManager().getRepository(User);\n    const users &#x3D; await userRepository.find();\n\n    ctx.status &#x3D; 200;\n    ctx.body &#x3D; users;\n  &#125;\n\n  public static async showUserDetail(ctx: Context) &#123;\n    const userRepository &#x3D; getManager().getRepository(User);\n    const user &#x3D; await userRepository.findOne(+ctx.params.id);\n\n    if (user) &#123;\n      ctx.status &#x3D; 200;\n      ctx.body &#x3D; user;\n    &#125; else &#123;\n      ctx.status &#x3D; 404;\n    &#125;\n  &#125;\n\n  public static async updateUser(ctx: Context) &#123;\n    const userRepository &#x3D; getManager().getRepository(User);\n    await userRepository.update(+ctx.params.id, ctx.request.body);\n    const updatedUser &#x3D; await userRepository.findOne(+ctx.params.id);\n\n    if (updatedUser) &#123;\n      ctx.status &#x3D; 200;\n      ctx.body &#x3D; updatedUser;\n    &#125; else &#123;\n      ctx.status &#x3D; 404;\n    &#125;\n  &#125;\n\n  public static async deleteUser(ctx: Context) &#123;\n    const userRepository &#x3D; getManager().getRepository(User);\n    await userRepository.delete(+ctx.params.id);\n\n    ctx.status &#x3D; 204;\n  &#125;\n&#125;\n\nTypeORM 中操作数据模型主要是通过Repository实现的，通过getManager().getReposity(Model)获取到\n\n\n\n\n\n\n\n\n\n关于 Repository 的查询 API，参考reposity-api。\n5.2 实现 AuthCotroller：安装 npm 加密算法包：这里采用 Argon2：\nnpm install argon2\n\n实现具体的 AuthCotroller 的逻辑：\nexport default class AuthController &#123;\n  public static async login(ctx: Context) &#123;\n    ctx.body &#x3D; &quot;Login controller&quot;;\n  &#125;\n\n  public static async register(ctx: Context) &#123;\n    console.log(ctx.request.body);\n\n    const userRepository &#x3D; getManager().getRepository(User);\n\n    const newUser &#x3D; new User();\n\n    const &#123;\n      request: &#123;\n        body: &#123; name, email, password &#125;,\n      &#125;,\n    &#125; &#x3D; ctx;\n    newUser.name &#x3D; name;\n    newUser.email &#x3D; email;\n    newUser.password &#x3D; password;\n\n    const user &#x3D; await userRepository.save(newUser);\n\n    ctx.status &#x3D; 201;\n    ctx.body &#x3D; user;\n  &#125;\n&#125;\n\n七. 实现 JWT 鉴权:\n\n\n\n\n\n\n\n\nJSON Web Token 是一种流行的 RESTFUL API 鉴权方案，其原理（可参考）\n安装相关的 npm 包：\nnpm install koa-jwt jsonwebtoken\nnpm install @types/jsonwebtoken -D\n\n创建 src/constants.ts，用于存放 JWT Secret 常量：\n&#x2F;&#x2F; src&#x2F;constants.ts\nexport const JWT_SECRET &#x3D; &quot;secret&quot;; &#x2F;&#x2F; 实际开发中，用替换成一个足够复杂的字符串，并且最好通过环境变量的方式注入\n\n1.重新规划路由\n所有请求都可以直接访问未受保护的路由，但是受保护的路由就放在 JWT 中间件的后面（或者从洋葱模型的角度看是“里面”），这样对于没有携带 JWT Token 的请求就直接返回，而不会继续传递下去\n打开src/routers.ts路由文件，做如下修改：\nimport Router from \"@koa/router\";\n\nimport AuthController from \"./controllers/auth\";\nimport UserController from \"./controllers/user\";\n\nconst unprotectedRouter = new Router();\nconst protectedRouter = new Router();\n\n// auth相关路由\nunprotectedRouter.post(\"/auth/login\", AuthController.login);\nunprotectedRouter.post(\"/auth/register\", AuthController.register);\n\n// user相关路由\nprotectedRouter.get(\"/users\", UserController.listUsers);\nprotectedRouter.get(\"/users/:id\", UserController.showUserDetail);\n\nprotectedRouter.put(\"users/:id\", UserController.updateUser);\n\nprotectedRouter.delete(\"/users:id\", UserController.deleteUser);\n\nexport &#123; protectedRouter, unprotectedRouter &#125;;\n\n2.注册 JWT 中间件注册 JWT 中间件，并在其前后注册不需要保护的路由unprotectedRouter和需要保护的路由protectedRouter\n\n\n\n\n\n\n\n\n\n在 JWT 中间件注册完毕后，如果用户请求携带了有效的 Token，后面的 protectedRouter 就可以通过 ctx.state.user 获取到 Token 的内容（更精确的说法是 Payload，负载，一般是用户的关键信息，例如 ID）了；反之，如果 Token 缺失或无效，那么 JWT 中间件会直接自动返回 401 错误。关于 koa-jwt 的更多使用细节，请参考其文档。\n3.在 Login 中签发 JWT Token\n// src/controllers/auth.ts\n// ...\nimport jwt from \"jsonwebtoken\";\n\n// ...\nimport &#123; JWT_SECRET &#125; from \"../constants\";\n\nexport default class AuthController &#123;\n  public static async login(ctx: Context) &#123;\n    const userRepository = getManager().getRepository(User);\n\n    const user = await userRepository\n      .createQueryBuilder()\n      .where(&#123; name: ctx.request.body.name &#125;)\n      .addSelect(\"User.password\")\n      .getOne();\n\n    if (!user) &#123;\n      ctx.status = 401;\n      ctx.body = &#123; message: \"用户名不存在\" &#125;;\n    &#125; else if (await argon2.verify(user.password, ctx.request.body.password)) &#123;\n      ctx.status = 200;\n      ctx.body = &#123; token: jwt.sign(&#123; id: user.id &#125;, JWT_SECRET) &#125;;\n    &#125; else &#123;\n      ctx.status = 401;\n      ctx.body = &#123; message: \"密码错误\" &#125;;\n    &#125;\n  &#125;\n\n  // ...\n&#125;\n\n在 login 中，我们首先根据用户名（请求体中的 name 字段）查询对应的用户，如果该用户不存在，则直接返回 401；存在的话再通过 argon2.verify 来验证请求体中的明文密码 password 是否和数据库中存储的加密密码是否一致，如果一致则通过 jwt.sign 签发 Token，如果不一致则还是返回 401。\n这里的 Token 负载就是标识用户 ID 的对象 &#123; id: user.id &#125; ，这样后面鉴权成功后就可以通过 ctx.user.id 来获取用户 ID。\n这里还遇到了一个小 bug：\n登录接口使用 post 传参，参数、路由均无出错，返回的却都是 404，响应体也为空\n这是原因 controller 中使用到了异步的访问数据库 api，但是方法调用忘记加await，而 koa 的 ctx 在没有任何改动的情况下，默认返回 status 就是 404，body 也为空\n总结一下可能出现 404 的原因:\n\n如果浏览器请求宝 404，可能是接口 url 没写对，或者 post 参数名出错（即找不到后端对应的 controller 方法）\n如果浏览器没有报错，而 response 返回 404，且后端 api 逻辑正常，可能是没有操作 koa 的 ctx，修改 body 和 status\nasync 方法已经修改了 ctx，但调用时没有加 await\n\n3.在 User 控制器中添加访问控制Token 的中间件和签发都搞定之后，最后一步就是在合适的地方校验用户的 Token，确认其是否有足够的权限。最典型的场景便是，在更新或删除用户时，我们要确保是用户本人在操作。打开 src/controllers/user.ts ，代码如下：\n// src/controllers/user.ts\n// ...\n\nexport default class UserController &#123;\n  // ...\n\n  public static async updateUser(ctx: Context) &#123;\n    const userId = +ctx.params.id;\n\n    if (userId !== +ctx.state.user.id) &#123;\n      ctx.status = 403;\n      ctx.body = &#123; message: \"无权进行此操作\" &#125;;\n      return;\n    &#125;\n\n    const userRepository = getManager().getRepository(User);\n    await userRepository.update(userId, ctx.request.body);\n    const updatedUser = await userRepository.findOne(userId);\n\n    // ...\n  &#125;\n\n  public static async deleteUser(ctx: Context) &#123;\n    const userId = +ctx.params.id;\n\n    if (userId !== +ctx.state.user.id) &#123;\n      ctx.status = 403;\n      ctx.body = &#123; message: \"无权进行此操作\" &#125;;\n      return;\n    &#125;\n\n    const userRepository = getManager().getRepository(User);\n    await userRepository.delete(userId);\n\n    ctx.status = 204;\n  &#125;\n&#125;\n\n两个 Controller 的鉴权逻辑基本相同，我们通过比较 ctx.params.id 和 ctx.state.user.id 是否相同，如果不相同则返回 403 Forbidden 错误，相同则继续执行相应的数据库操作。\n","slug":"koa基本使用","date":"2021-07-03T12:54:26.000Z","categories_index":"node","tags_index":"node,koa","author_index":"EVE"},{"id":"621ca8e76bddb73a9eb22e1cc02afcf5","title":"Node.js 实现简单的 Web 路由","content":"Node.js 路由路由: Web 服务器根据用户输入的不同 url 返回不同的页面。\n\n\n例如登录页面 login 和注册页面 register\n#默认端口都为80\nhttp:&#x2F;&#x2F;localhost:80&#x2F;login\nhttp:&#x2F;&#x2F;localhost:80&#x2F;register\n\n实现思路\n建立所需要的文件, index.js 文件作为入口文件, router.js 实现路由响应, server.js 用来处理请求. file 文件夹下就建立几个不同的页面, 展示路由跳转.\n \n\n创建一个 http 服务器，用于监听用户输入的 request 参数, 获取 request.url\n &#x2F;&#x2F; server.js\nconst http &#x3D; require(&quot;http&quot;);\n\nhttp.createServer(onRequest).listen(&#39;8888&#39;);\n\nfunction onRequest(req, res) &#123; &#x2F;&#x2F; onRequest处理用户请求\n    console.log(req.url);\n&#125;\n解析 url，得到具体的请求页面，也就是路由入口\n &#x2F;&#x2F; server.js\nconst url &#x3D; require(&quot;url&quot;);\n\nfunction onRequest(req, res) &#123;\n    console.log(req.url);\n\n    let myUrl &#x3D; url.parse(req.url);\n    console.log(myUrl);\n&#125;\n\n根据 url 渲染不同页面\n const http &#x3D; require(&quot;http&quot;);\nconst fs &#x3D; require(&quot;fs&quot;);\n\nlet Response &#x3D; function(res, filePath) &#123;\nfs.readFile(filePath, (err, data) &#x3D;&gt; &#123;\n    if(err) &#123;\n        res.writeHead(404, &#123;\n            &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n        &#125;);\n        res.end(&quot;error&quot;)\n    &#125; else &#123;\n        res.writeHead(200, &#123;\n            &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n        &#125;);\n        res.end(data);\n    &#125;\n&#125;)\n&#125;\n\n\nlet router &#x3D; function(req, res) &#123;\nif(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页\n    index.index(res);\n&#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123; &#x2F;&#x2F; 古诗页面\n    Response(res, poem);\n&#125; else &#123;  &#x2F;&#x2F; 不存在的页面\n    Response(res, error);\n&#125;\n&#125;\n\n\n完整代码以上几步就能做一个简单的 node 路由 demo 了, 下面贴上完整的代码:\n&#x2F;&#x2F; 入口文件\n&#x2F;&#x2F; index.js\nvar server &#x3D; require(&quot;.&#x2F;server&quot;);\n\nserver.start();\n\n&#x2F;&#x2F; router.js\n&#x2F;&#x2F; 需响应的文件路由\n\nconst http &#x3D; require(&quot;http&quot;);\n\n&#x2F;&#x2F; 导入文件系统模块\n&#x2F;&#x2F; 所有的文件系统操作都具有同步的、回调的、以及基于 promise 的形式。\nconst fs &#x3D; require(&quot;fs&quot;);\n\nconst index &#x3D; require(&quot;.&#x2F;file&#x2F;index&quot;); &#x2F;&#x2F; 主页路由模块\nconst error &#x3D; &quot;.&#x2F;file&#x2F;error404.html&quot;; &#x2F;&#x2F; 错误处理路由\nconst poem &#x3D; &quot;.&#x2F;file&#x2F;poem.html&quot;;       &#x2F;&#x2F; 古诗路由\n\nlet Response &#x3D; function(res, filePath) &#123;\n    fs.readFile(filePath, (err, data) &#x3D;&gt; &#123;\n        if(err) &#123;\n            res.writeHead(404, &#123;\n                &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n            &#125;);\n            res.end(&quot;error&quot;)\n        &#125; else &#123;\n            res.writeHead(200, &#123;\n                &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n            &#125;);\n            res.end(data);\n        &#125;\n    &#125;)\n&#125;\n\n\nlet router &#x3D; function(req, res) &#123;\n    if(req.url &#x3D;&#x3D; &#39;&#x2F;index&#39; || req.url &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; &#x2F;&#x2F;主页\n        index.index(res);\n    &#125; else if(req.url &#x3D;&#x3D; &#39;&#x2F;poem&#39;) &#123;\n        Response(res, poem);\n    &#125; else &#123;\n        Response(res, error);\n    &#125;\n&#125;\n\nexports.router &#x3D; router;\n\n\n&#x2F;&#x2F; server.js\n&#x2F;&#x2F; 服务端的start函数, 用于开启一个web服务器\n\n&#x2F;&#x2F; 导入http模块，使用HTTP服务器和客户端\n\n&#x2F;&#x2F; Node中的HTTP API是非常底层的，\n&#x2F;&#x2F; 仅进行流处理和消息解析。它将消息解析为消息头和消息体，但不会解析具体的消息头或消息体\nconst http &#x3D; require(&quot;http&quot;);\n\n&#x2F;&#x2F; 导入url模块，用于处理与解析 URL。\n\n&#x2F;&#x2F; URL字符串是结构化的字符串，包含多个含义不同的组成部分。解析后返回的是URL对象\n&#x2F;&#x2F; url 模块提供了两套 API 来处理 URL：一个是旧版本传统的 API，一个是实现了 WHATWG标准的新 API。\nconst url &#x3D; require(&quot;url&quot;);\n\nconst router &#x3D; require(&#39;.&#x2F;router&#39;)\n\n\nfunction start() &#123;\n    function onRequest(req, res) &#123;\n        if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;favicon.ico&#39;) &#123;\n            &#x2F;&#x2F; 浏览器默认会请求网站根目录的favicon.ico图标，如果网站根目录没有会产生 404。出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。\n            return ;\n        &#125;\n\n        console.log(&#39;End of line&#39;);\n        console.log(req.url);\n\n        let myUrl &#x3D; url.parse(req.url);\n        console.log(myUrl);\n\n        router.router(req, res)\n    &#125;\n\n    http.createServer(onRequest).listen(&#39;8888&#39;)\n    console.log(&quot;Server is running at &quot; + &quot;http:&#x2F;&#x2F;localhost:8888&quot;);\n&#125;\n\nexports.start &#x3D; start;\n","slug":"node.js路由","date":"2020-10-11T07:54:26.000Z","categories_index":"node","tags_index":"node","author_index":"EVE"}]